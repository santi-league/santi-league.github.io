<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è®¡åˆ†å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .language-switcher a {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #f0f1ff;
            color: #4b50c5;
            padding: 8px 16px;
            border-radius: 20px;
            text-decoration: none;
            font-weight: 600;
            border: 1px solid rgba(102, 126, 234, 0.4);
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .language-switcher a:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
        }

        .language-switcher a.active {
            background: #667eea;
            color: white;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        input, select, button {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: all 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .top-right-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .language-switcher,
        .rule-switch {
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .rule-btn-compact {
            padding: 8px 16px;
            background: white;
            border: 2px solid #ddd;
            color: #666;
            border-radius: 15px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .rule-btn-compact:hover:not(:disabled) {
            background: #f0f0f0;
            border-color: #667eea;
            color: #667eea;
        }

        .rule-btn-compact.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }

        .rule-btn-compact:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .scores-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .player-score {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid #667eea;
            transition: all 0.3s;
        }

        .player-score.dealer {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            border-color: #f39c12;
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
        }

        .player-score input {
            background: transparent;
            border: none;
            border-bottom: 2px solid #667eea;
            color: #667eea;
            font-weight: bold;
            font-size: 1em;
            text-align: center;
            padding: 5px;
            width: 100%;
            transition: all 0.3s;
        }

        .player-score.dealer input {
            border-bottom-color: #f39c12;
            color: #d35400;
        }

        .player-score input:focus {
            outline: none;
            border-bottom-color: #5568d3;
        }

        .player-score input::placeholder {
            color: #999;
        }

        .player-score .score {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            margin-top: 10px;
        }

        .record-form {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .history {
            max-height: 400px;
            overflow-y: auto;
        }

        .history-item {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item .details {
            flex: 1;
        }

        .history-item button {
            background: #dc3545;
            padding: 5px 15px;
            font-size: 14px;
        }

        .history-item button:hover {
            background: #c82333;
        }

        .hidden {
            display: none;
        }

        .error {
            color: #dc3545;
            font-weight: 600;
            padding: 10px;
            background: #f8d7da;
            border-radius: 5px;
            margin-top: 10px;
        }

        .success {
            color: #28a745;
            font-weight: 600;
            padding: 10px;
            background: #d4edda;
            border-radius: 5px;
            margin-top: 10px;
        }

        .dealer-badge {
            background: #ffc107;
            color: #333;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 5px;
        }

        .yaku-tag {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin: 5px 5px 5px 0;
            font-size: 0.9em;
        }

        .yaku-tag button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-weight: bold;
            margin-left: 5px;
            padding: 0;
            font-size: 1.1em;
        }

        .yaku-tag button:hover {
            color: #dc3545;
            transform: none;
            box-shadow: none;
        }

        .yaku-selector {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .yaku-selector input {
            flex: 1;
        }

        .yaku-selector button {
            padding: 10px 20px;
            white-space: nowrap;
        }

        .selected-yaku-list {
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
            min-height: 50px;
        }

        /* å“åº”å¼è®¾è®¡ - æ‰‹æœºç«¯é€‚é… */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
                border-radius: 10px;
            }

            .section {
                padding: 15px;
                margin-bottom: 20px;
            }

            h1 {
                font-size: 1.8em;
                margin-bottom: 20px;
            }

            .section h2 {
                font-size: 1.2em;
                margin-bottom: 10px;
            }

            .scores-display {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .player-score {
                padding: 15px;
            }

            .player-score input {
                font-size: 16px;
            }

            .player-score .score {
                font-size: 1.5em;
            }

            .record-form {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .rule-switch {
                top: 10px;
                right: 10px;
                padding: 6px;
            }

            .rule-btn-compact {
                padding: 8px 14px;
                font-size: 13px;
                min-height: 44px;
            }

            .history-item {
                padding: 10px;
                font-size: 14px;
            }

            /* å…³é”®ä¿®å¤ï¼šç¡®ä¿æŒ‰é’®åœ¨ç§»åŠ¨ç«¯å¯ç‚¹å‡» */
            button {
                padding: 14px 16px;
                font-size: 16px;
                min-height: 44px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
            }

            input, select {
                font-size: 16px;
                min-height: 44px;
            }

            /* å†å²è®°å½•æ’¤é”€æŒ‰é’® */
            .history-item button {
                min-height: 36px;
                padding: 8px 16px;
                font-size: 14px;
            }

            /* å½¹ç§åˆ é™¤æŒ‰é’® */
            .yaku-tag button {
                padding: 4px;
                font-size: 16px;
                min-width: 24px;
                min-height: 24px;
            }
        }

        /* æ›´å°çš„æ‰‹æœºå±å¹• */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .container {
                padding: 10px;
            }

            .section {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
            }

            .scores-display {
                grid-template-columns: 1fr;
            }

            #game-info-compact {
                font-size: 12px;
            }

            /* ç¡®ä¿å°å±å¹•ä¸ŠæŒ‰é’®ä¹Ÿè¶³å¤Ÿå¤§ */
            button {
                padding: 14px 12px;
                font-size: 16px;
                min-height: 44px;
            }
        }
    </style>
</head>
<body>
    <div class="top-right-panel">
        <div class="language-switcher">
            <a href="game_tracker.html?lang=zh" data-lang="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</a>
            <a href="game_tracker.html?lang=en" data-lang="en">ğŸ‡ºğŸ‡¸ English</a>
        </div>
        <div class="rule-switch">
            <button class="rule-btn-compact active" data-rule="mleague" title="M-League (25000ç‚¹)">M-League</button>
            <button class="rule-btn-compact" data-rule="wrc" title="WRC (30000ç‚¹)">WRC</button>
        </div>
    </div>

    <div class="container">
        <h1 data-i18n="title_main">ğŸ€„ éº»å°†ç‚¹æ•°è®¡ç®—å™¨</h1>

        <!-- ç‚¹æ•°æ˜¾ç¤º -->
        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                <h2 data-i18n="section_current_scores" style="margin: 0;">å½“å‰ç‚¹æ•°</h2>
                <div id="game-info-compact" style="font-size: 14px; color: #667eea; font-weight: 600;">
                    <span id="current-round">ä¸œ1å±€</span>
                    <span id="honba-display" style="margin-left: 15px;">0æœ¬åœº</span>
                    <span style="margin-left: 15px;" data-i18n="label_riichi_sticks_prefix">ä¾›æ‰˜</span>: <span id="riichi-sticks">0</span><span data-i18n="label_riichi_sticks_suffix">æœ¬</span>
                </div>
            </div>
            <div class="scores-display" id="scores-display"></div>
            <div id="game-end-notice" style="display: none; margin-top: 20px; padding: 20px; background: #ffc107; border-radius: 10px; text-align: center;">
                <h3 data-i18n="game_end_title" style="color: #333; margin-bottom: 15px; font-size: 1.5em;">ğŸ† å¯¹å±€ç»“æŸ ğŸ†</h3>
                <div id="final-results"></div>
            </div>
        </div>

        <!-- è®°å½•å’Œç‰Œ -->
        <div class="section">
            <h2 data-i18n="section_record_win">è®°å½•å’Œç‰Œ</h2>
            <div class="record-form">
                <div class="input-group">
                    <label data-i18n="label_winner">å’Œç‰Œè€…</label>
                    <select id="winner"></select>
                </div>
                <div class="input-group">
                    <label data-i18n="label_loser">ç‚¹ç‚®è€…ï¼ˆè‡ªæ‘¸é€‰æ‹©"è‡ªæ‘¸"ï¼‰</label>
                    <select id="loser">
                        <option value="tsumo" data-i18n-option="option_tsumo">è‡ªæ‘¸</option>
                    </select>
                </div>
            </div>
            <div style="margin-top: 15px;">
                <label style="font-weight: 600; margin-bottom: 10px; display: block;" data-i18n="label_choose_yaku">é€‰æ‹©å½¹ç§</label>
                <div class="yaku-selector">
                    <div class="input-group" style="flex: 1; margin: 0;">
                        <input type="text" id="yaku-search" list="yaku-datalist" placeholder="è¾“å…¥æœç´¢æˆ–ä»åˆ—è¡¨é€‰æ‹©..." data-i18n-placeholder="placeholder_yaku_search">
                        <datalist id="yaku-datalist"></datalist>
                    </div>
                    <button id="add-yaku-btn" type="button" style="background: #28a745;" data-i18n="button_add_yaku">æ·»åŠ </button>
                </div>
                <div class="selected-yaku-list" id="selected-yaku-list">
                    <div style="color: #999;" data-i18n="selected_yaku_placeholder">è¯·é€‰æ‹©å½¹ç§...</div>
                </div>
            </div>
            <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <div class="input-group">
                    <label data-i18n="label_dora">å®ç‰Œ</label>
                    <input type="number" id="dora-count" value="0" min="0" max="20" style="text-align: center;">
                </div>
                <div class="input-group">
                    <label data-i18n="label_aka_dora">èµ¤å®ç‰Œ</label>
                    <input type="number" id="aka-dora-count" value="0" min="0" max="3" style="text-align: center;">
                </div>
                <div class="input-group">
                    <label data-i18n="label_ura_dora">é‡Œå®ç‰Œ</label>
                    <input type="number" id="ura-dora-count" value="0" min="0" max="20" style="text-align: center;">
                </div>
            </div>
            <div class="record-form" style="margin-top: 15px;">
                <div class="input-group">
                    <label data-i18n="label_fu">ç¬¦æ•°</label>
                    <select id="fu">
                        <option value="20" data-i18n-option="fu_value">20ç¬¦</option>
                        <option value="25" data-i18n-option="fu_value">25ç¬¦ï¼ˆä¸ƒå¯¹å­ï¼‰</option>
                        <option value="30" data-i18n-option="fu_value" selected>30ç¬¦</option>
                        <option value="40" data-i18n-option="fu_value">40ç¬¦</option>
                        <option value="50" data-i18n-option="fu_value">50ç¬¦</option>
                        <option value="60" data-i18n-option="fu_value">60ç¬¦</option>
                        <option value="70" data-i18n-option="fu_value">70ç¬¦</option>
                        <option value="80" data-i18n-option="fu_value">80ç¬¦</option>
                        <option value="90" data-i18n-option="fu_value">90ç¬¦</option>
                        <option value="100" data-i18n-option="fu_value">100ç¬¦</option>
                        <option value="110" data-i18n-option="fu_value">110ç¬¦</option>
                    </select>
                </div>
                <div class="input-group">
                    <div class="checkbox-group" style="align-items: center; height: 100%; padding-top: 25px;">
                        <input type="checkbox" id="menzen" checked>
                        <label for="menzen" data-i18n="label_menzen">é—¨æ¸…</label>
                    </div>
                </div>
            </div>
            <div id="yaku-preview" style="margin-top: 15px; padding: 15px; background: white; border-radius: 5px; display: none;">
                <div style="font-weight: 600; margin-bottom: 10px;" data-i18n="preview_title">è®¡ç®—é¢„è§ˆï¼š</div>
                <div id="yaku-recognized" style="color: #28a745; margin-bottom: 5px;"></div>
                <div id="yaku-unrecognized" style="color: #dc3545; margin-bottom: 5px;"></div>
                <div id="yaku-han" style="font-weight: bold; font-size: 1.1em; margin-bottom: 5px;"></div>
                <div id="yaku-points" style="font-weight: bold; font-size: 1.2em; color: #667eea;"></div>
            </div>
            <div style="margin-top: 15px; padding: 15px; background: white; border-radius: 5px;">
                <label style="font-weight: 600; margin-bottom: 10px; display: block;" data-i18n="label_riichi_status">ç«‹ç›´æƒ…å†µï¼ˆå‹¾é€‰ç«‹ç›´çš„ç©å®¶ï¼‰</label>
                <div style="display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 8px;">
                    <div class="checkbox-group">
                        <input type="checkbox" id="riichi-0">
                        <label for="riichi-0" id="riichi-label-0">ç©å®¶1</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="riichi-1">
                        <label for="riichi-1" id="riichi-label-1">ç©å®¶2</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="riichi-2">
                        <label for="riichi-2" id="riichi-label-2">ç©å®¶3</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="riichi-3">
                        <label for="riichi-3" id="riichi-label-3">ç©å®¶4</label>
                    </div>
                </div>
            </div>
            <button id="record-win-btn" type="button" style="width: 100%; margin-top: 15px;" data-i18n="button_record_win">è®°å½•å’Œç‰Œ</button>
            <div id="message"></div>
        </div>

        <!-- è®°å½•æµå±€ -->
        <div class="section">
            <h2 data-i18n="section_record_ryuukyoku">è®°å½•æµå±€</h2>
            <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 5px;">
                <label style="font-weight: 600; margin-bottom: 10px; display: block;" data-i18n="label_tenpai_players">å¬ç‰Œç©å®¶ï¼ˆå‹¾é€‰å¬ç‰Œçš„ç©å®¶ï¼‰</label>
                <div style="display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 8px;">
                    <div class="checkbox-group">
                        <input type="checkbox" id="tenpai-0">
                        <label for="tenpai-0" id="tenpai-label-0">ç©å®¶1</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="tenpai-1">
                        <label for="tenpai-1" id="tenpai-label-1">ç©å®¶2</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="tenpai-2">
                        <label for="tenpai-2" id="tenpai-label-2">ç©å®¶3</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="tenpai-3">
                        <label for="tenpai-3" id="tenpai-label-3">ç©å®¶4</label>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 5px;">
                <label style="font-weight: 600; margin-bottom: 10px; display: block;" data-i18n="label_riichi_status">ç«‹ç›´æƒ…å†µï¼ˆå‹¾é€‰ç«‹ç›´çš„ç©å®¶ï¼‰</label>
                <div style="display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 8px;">
                    <div class="checkbox-group">
                        <input type="checkbox" id="ryuukyoku-riichi-0">
                        <label for="ryuukyoku-riichi-0" id="ryuukyoku-riichi-label-0">ç©å®¶1</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="ryuukyoku-riichi-1">
                        <label for="ryuukyoku-riichi-1" id="ryuukyoku-riichi-label-1">ç©å®¶2</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="ryuukyoku-riichi-2">
                        <label for="ryuukyoku-riichi-2" id="ryuukyoku-riichi-label-2">ç©å®¶3</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="ryuukyoku-riichi-3">
                        <label for="ryuukyoku-riichi-3" id="ryuukyoku-riichi-label-3">ç©å®¶4</label>
                    </div>
                </div>
            </div>
            <button id="record-ryuukyoku-btn" type="button" style="width: 100%; background: #28a745;" data-i18n="button_record_ryuukyoku">è®°å½•æµå±€</button>
            <div id="ryuukyoku-message"></div>
        </div>

        <!-- å¯¹å±€å†å² -->
        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                <h2 style="margin: 0;" data-i18n="section_history">å¯¹å±€å†å²</h2>
                <div style="display: flex; gap: 10px;">
                    <button id="redo-btn" type="button" style="min-width: 100px; padding: 8px 16px; background: #ffc107;" data-i18n="button_redo" disabled>æ’¤é”€æ’¤é”€</button>
                    <button id="clear-history-btn" type="button" style="min-width: 100px; padding: 8px 16px; background: #dc3545;" data-i18n="button_clear_history">æ¸…ç©ºå†å²</button>
                </div>
            </div>
            <div class="history" id="history"></div>
        </div>

        <!-- å¯¹å±€JSONæ‘˜è¦ -->
        <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                <h2 style="margin: 0;" data-i18n="section_json">å¯¹å±€æ•°æ®ï¼ˆJSONï¼‰</h2>
                <div style="display: flex; gap: 10px;">
                    <button id="copy-game-summary" style="min-width: 100px; padding: 8px 16px;" data-i18n="button_copy">å¤åˆ¶æ•°æ®</button>
                    <button id="import-game-data" style="min-width: 100px; padding: 8px 16px; background: #28a745;" data-i18n="button_import">å¯¼å…¥æ•°æ®</button>
                </div>
            </div>
            <pre id="game-summary-json" style="min-height: 160px; max-height: 240px; background: #1e1e1e; color: #d4d4d4; padding: 10px; border-radius: 5px; overflow: auto; white-space: pre; font-size: 0.8em; line-height: 1.35;"></pre>
            <div id="copy-status" style="margin-top: 6px; font-size: 0.85em; color: #28a745;"></div>
        </div>
    </div>

    <script>
        // å½¹ç§æ•°æ®åº“
        const params = new URLSearchParams(window.location.search);
        const LANGUAGE = (params.get('lang') || '').toLowerCase() === 'en' ? 'en' : 'zh';

        const yakuDatabase = {
            // 1ç•ªå½¹
            'ç«‹ç›´': 1, 'riichi': 1, 'ãƒªãƒ¼ãƒ': 1,
            'ä¸€å‘': 1, 'ippatsu': 1, 'ã‚¤ãƒƒãƒ‘ãƒ„': 1,
            'é—¨å‰æ¸…è‡ªæ‘¸å’Œ': 1, 'é—¨æ¸…': 1, 'tsumo': 1, 'ãƒ„ãƒ¢': 1,
            'å¹³å’Œ': 1, 'pinfu': 1, 'ãƒ”ãƒ³ãƒ•': 1,
            'æ–­å¹ºä¹': 1, 'æ–­å¹º': 1, 'tanyao': 1, 'ã‚¿ãƒ³ãƒ¤ã‚ª': 1,
            'ä¸€æ¯å£': 1, 'iipeiko': 1, 'ã‚¤ãƒ¼ãƒšãƒ¼ã‚³ãƒ¼': 1,
            'å²­ä¸Šå¼€èŠ±': 1, 'å²­ä¸Š': 1, 'rinshan': 1, 'ãƒªãƒ³ã‚·ãƒ£ãƒ³': 1,
            'æªæ ': 1, 'chankan': 1, 'ãƒãƒ£ãƒ³ã‚«ãƒ³': 1,
            'æµ·åº•æ‘¸æœˆ': 1, 'æµ·åº•': 1, 'haitei': 1, 'ãƒã‚¤ãƒ†ã‚¤': 1,
            'æ²³åº•æé±¼': 1, 'æ²³åº•': 1, 'houtei': 1, 'ãƒ›ã‚¦ãƒ†ã‚¤': 1,
            'å½¹ç‰Œç™½': 1, 'ç™½': 1, 'haku': 1, 'ãƒã‚¯': 1,
            'å½¹ç‰Œå‘': 1, 'å‘': 1, 'hatsu': 1, 'ãƒãƒ„': 1,
            'å½¹ç‰Œä¸­': 1, 'ä¸­': 1, 'chun': 1, 'ãƒãƒ¥ãƒ³': 1,
            'è‡ªé£ä¸œ': 1, 'ä¸œ': 1, 'ton': 1, 'ãƒˆãƒ³': 1,
            'è‡ªé£å—': 1, 'å—': 1, 'nan': 1, 'ãƒŠãƒ³': 1,
            'è‡ªé£è¥¿': 1, 'è¥¿': 1, 'sha': 1, 'ã‚·ãƒ£ãƒ¼': 1,
            'è‡ªé£åŒ—': 1, 'åŒ—': 1, 'pei': 1, 'ãƒšãƒ¼': 1,
            'åœºé£ä¸œ': 1, 'åœºä¸œ': 1,
            'åœºé£å—': 1, 'åœºå—': 1,
            'åœºé£è¥¿': 1, 'åœºè¥¿': 1,
            'åœºé£åŒ—': 1, 'åœºåŒ—': 1,

            // 2ç•ªå½¹
            'ä¸‰è‰²åŒé¡º': 2, 'ä¸‰è‰²': 2, 'sanshoku': 2, 'ã‚µãƒ³ã‚·ãƒ§ã‚¯': 2,
            'ä¸€æ°”é€šè´¯': 2, 'ä¸€é€š': 2, 'ikkitsuukan': 2, 'ã‚¤ãƒƒãƒ„ãƒ¼': 2,
            'æ··å…¨å¸¦å¹ºä¹': 2, 'æ··å…¨': 2, 'chanta': 2, 'ãƒãƒ£ãƒ³ã‚¿': 2,
            'ä¸ƒå¯¹å­': 2, 'ä¸ƒå¯¹': 2, 'chiitoitsu': 2, 'ãƒãƒ¼ãƒˆã‚¤ãƒ„': 2,
            'å¯¹å¯¹å’Œ': 2, 'å¯¹å¯¹': 2, 'toitoi': 2, 'ãƒˆã‚¤ãƒˆã‚¤': 2,
            'ä¸‰æš—åˆ»': 2, 'sanankou': 2, 'ã‚µãƒ³ã‚¢ãƒ³ã‚³ãƒ¼': 2,
            'ä¸‰æ å­': 2, 'sankantsu': 2, 'ã‚µãƒ³ã‚«ãƒ³ãƒ„': 2,
            'å°ä¸‰å…ƒ': 2, 'shousangen': 2, 'ã‚·ãƒ§ã‚¦ã‚µãƒ³ã‚²ãƒ³': 2,
            'æ··è€å¤´': 2, 'honroutou': 2, 'ãƒ›ãƒ³ãƒ­ã‚¦ãƒˆã‚¦': 2,
            'åŒç«‹ç›´': 2, 'åŒç«‹': 2, 'daburu riichi': 2, 'ãƒ€ãƒ–ãƒ«ãƒªãƒ¼ãƒ': 2, 'wç«‹ç›´': 2,

            // 3ç•ªå½¹
            'æ··ä¸€è‰²': 3, 'æ··ä¸€': 3, 'honitsu': 3, 'ãƒ›ãƒ³ã‚¤ãƒ„': 3,
            'çº¯å…¨å¸¦å¹ºä¹': 3, 'çº¯å…¨': 3, 'junchan': 3, 'ã‚¸ãƒ¥ãƒ³ãƒãƒ£ãƒ³': 3,
            'äºŒæ¯å£': 3, 'ryanpeikou': 3, 'ãƒªãƒ£ãƒ³ãƒšãƒ¼ã‚³ãƒ¼': 3,

            // 6ç•ªå½¹
            'æ¸…ä¸€è‰²': 6, 'æ¸…ä¸€': 6, 'chinitsu': 6, 'ãƒãƒ³ã‚¤ãƒ„': 6,

            // å½¹æ»¡ (13ç•ª)
            'å¤©å’Œ': 13, 'tenhou': 13, 'ãƒ†ãƒ³ãƒ›ã‚¦': 13,
            'åœ°å’Œ': 13, 'chiihou': 13, 'ãƒãƒ¼ãƒ›ã‚¦': 13,
            'å¤§ä¸‰å…ƒ': 13, 'daisangen': 13, 'ãƒ€ã‚¤ã‚µãƒ³ã‚²ãƒ³': 13,
            'å››æš—åˆ»': 13, 'suuankou': 13, 'ã‚¹ãƒ¼ã‚¢ãƒ³ã‚³ãƒ¼': 13,
            'å­—ä¸€è‰²': 13, 'tsuuiisou': 13, 'ãƒ„ãƒ¼ã‚¤ãƒ¼ã‚½ãƒ¼': 13,
            'ç»¿ä¸€è‰²': 13, 'ryuuiisou': 13, 'ãƒªãƒ¥ãƒ¼ã‚¤ãƒ¼ã‚½ãƒ¼': 13,
            'æ¸…è€å¤´': 13, 'chinroutou': 13, 'ãƒãƒ³ãƒ­ã‚¦ãƒˆã‚¦': 13,
            'ä¹è²å®ç¯': 13, 'chuuren': 13, 'ãƒãƒ¥ã‚¦ãƒ¬ãƒ³': 13,
            'å››æ å­': 13, 'suukantsu': 13, 'ã‚¹ãƒ¼ã‚«ãƒ³ãƒ„': 13,
            'å›½å£«æ— åŒ': 13, 'å›½å£«': 13, 'kokushi': 13, 'ã‚³ã‚¯ã‚·': 13,
            'å¤§å››å–œ': 13, 'daisuushi': 13, 'ãƒ€ã‚¤ã‚¹ãƒ¼ã‚·ãƒ¼': 13,
            'å°å››å–œ': 13, 'shousuushi': 13, 'ã‚·ãƒ§ã‚¦ã‚¹ãƒ¼ã‚·ãƒ¼': 13,

            // åŒå€å½¹æ»¡ (26ç•ª)
            'å››æš—åˆ»å•éª‘': 26, 'suuankou tanki': 26,
            'å›½å£«æ— åŒåä¸‰é¢': 26, 'å›½å£«åä¸‰é¢': 26, 'kokushi 13': 26,
            'çº¯æ­£ä¹è²å®ç¯': 26, 'çº¯æ­£ä¹è²': 26, 'chuuren 9': 26,
            'å¤§å››å–œ': 26, 'daisuushi': 26
        };

        // å‰¯éœ²æ—¶ç•ªæ•°ä¼šå‡å°‘çš„å½¹ç§
        const fuuroReducedYaku = {
            'ä¸‰è‰²åŒé¡º': -1, 'ä¸‰è‰²': -1, 'sanshoku': -1, 'ã‚µãƒ³ã‚·ãƒ§ã‚¯': -1,
            'ä¸€æ°”é€šè´¯': -1, 'ä¸€é€š': -1, 'ikkitsuukan': -1, 'ã‚¤ãƒƒãƒ„ãƒ¼': -1,
            'æ··å…¨å¸¦å¹ºä¹': -1, 'æ··å…¨': -1, 'chanta': -1, 'ãƒãƒ£ãƒ³ã‚¿': -1,
            'çº¯å…¨å¸¦å¹ºä¹': -1, 'çº¯å…¨': -1, 'junchan': -1, 'ã‚¸ãƒ¥ãƒ³ãƒãƒ£ãƒ³': -1,
            'æ··ä¸€è‰²': -1, 'æ··ä¸€': -1, 'honitsu': -1, 'ãƒ›ãƒ³ã‚¤ãƒ„': -1,
            'æ¸…ä¸€è‰²': -1, 'æ¸…ä¸€': -1, 'chinitsu': -1, 'ãƒãƒ³ã‚¤ãƒ„': -1
        };

        const I18N = {
            zh: {
                document_title: 'è®¡åˆ†å·¥å…·',
                title_main: 'ğŸ§® è®¡åˆ†å·¥å…·',
                section_current_scores: 'å½“å‰ç‚¹æ•°',
                label_riichi_sticks_prefix: 'ä¾›æ‰˜',
                label_riichi_sticks_suffix: 'æœ¬',
                game_end_title: 'ğŸ† å¯¹å±€ç»“æŸ ğŸ†',
                section_record_win: 'è®°å½•å’Œç‰Œ',
                label_winner: 'å’Œç‰Œè€…',
                label_loser: 'ç‚¹ç‚®è€…ï¼ˆè‡ªæ‘¸é€‰æ‹©"è‡ªæ‘¸"ï¼‰',
                option_tsumo: 'è‡ªæ‘¸',
                label_choose_yaku: 'é€‰æ‹©å½¹ç§',
                placeholder_yaku_search: 'è¾“å…¥æœç´¢æˆ–ä»åˆ—è¡¨é€‰æ‹©...',
                button_add_yaku: 'æ·»åŠ ',
                selected_yaku_placeholder: 'è¯·é€‰æ‹©å½¹ç§...',
                label_dora: 'å®ç‰Œ',
                label_aka_dora: 'èµ¤å®ç‰Œ',
                label_ura_dora: 'é‡Œå®ç‰Œ',
                label_fu: 'ç¬¦æ•°',
                option_fu: '{value}ç¬¦',
                option_fu_25: '25ç¬¦ï¼ˆä¸ƒå¯¹å­ï¼‰',
                label_menzen: 'é—¨æ¸…',
                preview_title: 'è®¡ç®—é¢„è§ˆï¼š',
                label_riichi_status: 'ç«‹ç›´æƒ…å†µï¼ˆå‹¾é€‰ç«‹ç›´çš„ç©å®¶ï¼‰',
                label_tenpai_players: 'å¬ç‰Œç©å®¶ï¼ˆå‹¾é€‰å¬ç‰Œçš„ç©å®¶ï¼‰',
                button_record_win: 'è®°å½•å’Œç‰Œ',
                button_record_ryuukyoku: 'è®°å½•æµå±€',
                section_record_ryuukyoku: 'è®°å½•æµå±€',
                section_history: 'å¯¹å±€å†å²',
                button_clear_history: 'æ¸…ç©ºå†å²',
                button_redo: 'æ’¤é”€æ’¤é”€',
                history_empty: 'æš‚æ— å¯¹å±€è®°å½•',
                undo_button: 'æ’¤é”€',
                section_json: 'å¯¹å±€æ•°æ®ï¼ˆJSONï¼‰',
                button_copy: 'å¤åˆ¶æ•°æ®',
                button_import: 'å¯¼å…¥æ•°æ®',
                table_rank: 'æ’å',
                table_player: 'ç©å®¶',
                table_final_score: 'æœ€ç»ˆç‚¹æ•°',
                table_raw_score: 'ç´ ç‚¹å·®',
                table_uma: 'é©¬ç‚¹',
                table_riichi: 'ä¾›æ‰˜',
                table_total: 'æ€»å¾—ç‚¹',
                rank_suffix: 'ä½',
                round_suffix: 'å±€',
                dealer_positions: ['ä¸œå®¶', 'å—å®¶', 'è¥¿å®¶', 'åŒ—å®¶'],
                player_placeholder: 'ç©å®¶{index}',
                copy_none: 'æ²¡æœ‰å¯å¤åˆ¶çš„æ•°æ®',
                copy_failed: 'å¤åˆ¶å¤±è´¥ï¼š',
                copy_auto: 'JSON æ•°æ®å·²è‡ªåŠ¨å¤åˆ¶',
                copy_success: 'å·²å¤åˆ¶åˆ°å‰ªè´´æ¿',
                copy_exec_failed: 'æ— æ³•å¤åˆ¶åˆ°å‰ªè´´æ¿',
                msg_enter_yaku: 'è¯·è¾“å…¥æˆ–é€‰æ‹©å½¹ç§',
                msg_unrecognized_yaku: 'æœªè¯†åˆ«çš„å½¹ç§: {name}',
                msg_duplicate_yaku: 'è¯¥å½¹ç§å·²æ·»åŠ ',
                msg_same_player: 'å’Œç‰Œè€…å’Œç‚¹ç‚®è€…ä¸èƒ½æ˜¯åŒä¸€äººï¼',
                msg_select_yaku_required: 'è¯·é€‰æ‹©å½¹ç§ï¼',
                msg_game_end: 'å¯¹å±€ç»“æŸï¼',
                msg_record_success: 'è®°å½•æˆåŠŸï¼',
                msg_ryuukyoku_success: 'æµå±€è®°å½•æˆåŠŸï¼',
                msg_ryuukyoku_success_end: 'æµå±€è®°å½•æˆåŠŸï¼å¯¹å±€ç»“æŸï¼',
                msg_no_history: 'æ²¡æœ‰å¯æ’¤é”€çš„è®°å½•',
                msg_undo_success: 'å·²æ’¤é”€ä¸Šä¸€å±€',
                msg_no_undo_stack: 'æ²¡æœ‰å¯é‡åšçš„è®°å½•',
                msg_redo_success: 'å·²é‡åšä¸Šä¸€å±€',
                msg_clear_confirm: 'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ',
                msg_history_cleared: 'å·²æ¸…ç©ºå†å²',
                msg_switch_rule_disabled: 'å¯¹å±€è¿›è¡Œä¸­æ— æ³•åˆ‡æ¢è§„åˆ™ï¼Œè¯·å…ˆæ¸…ç©ºå†å²è®°å½•',
                round_names: ['ä¸œ', 'å—', 'è¥¿', 'åŒ—'],
                honba_suffix: 'æœ¬åœº',
                dealer_label: 'åº„å®¶',
                ron_text: 'ç‚¹ç‚®',
                tsumo_text: 'è‡ªæ‘¸',
                total_han: 'æ€»ç•ªæ•°',
                han_unit: 'ç•ª',
                fu_unit: 'ç¬¦',
                dealer_tsumo_points: 'åº„å®¶è‡ªæ‘¸: {points}ç‚¹ All (æ¯äººæ”¯ä»˜{points}ç‚¹)',
                nondealer_tsumo_points: 'é—²å®¶è‡ªæ‘¸: é—²å®¶å„{small}ç‚¹, åº„å®¶{big}ç‚¹ (å…±{total}ç‚¹)',
                dealer_ron_points: 'åº„å®¶ç‚¹ç‚®: {points}ç‚¹',
                nondealer_ron_points: 'é—²å®¶ç‚¹ç‚®: {points}ç‚¹',
                extra_points_header: 'é¢å¤–: ',
                extra_honba: 'æœ¬åœº+{points}ç‚¹',
                extra_riichi: 'ç«‹ç›´æ£’+{points}ç‚¹',
                menzen_suffix_open: ' (å‰¯éœ²)',
                riichi_players_label: 'ç«‹ç›´',
                yaku_label: 'å½¹',
                dora_label_format: {
                    yaku: 'å½¹{han}ç•ª',
                    dora: 'å®ç‰Œ{count}ç•ª',
                    aka: 'èµ¤{count}ç•ª',
                    ura: 'é‡Œ{count}ç•ª'
                },
                history_ryuukyoku: 'æµå±€',
                history_continue: 'è¿åº„',
                history_change: 'è½®åº„',
                history_tenpai_prefix: 'å¬ç‰Œ: ',
                history_all_tenpai: 'å…¨å‘˜å¬ç‰Œ',
                history_all_noten: 'å…¨å‘˜æœªå¬ç‰Œ',
                history_winner_summary: '{winner} å’Œç‰Œ ({han}ç•ª{fu}ç¬¦{dealer})',
                history_dealer_suffix: ' åº„å®¶',
                history_loser_summary: '{loser} Â· {points}',
                history_tsumo_summary: 'è‡ªæ‘¸ Â· {points}',
                history_extra_separator: ' Â· ',
                summary_note_ron: 'è£å’Œ',
                summary_note_tsumo: 'è‡ªæ‘¸',
                json_copy_button: 'å¤åˆ¶æ•°æ®',
                history_score_changes: 'ç‚¹æ•°å˜åŒ–',
                history_riichi_changes: 'ä¾›æ‰˜å˜åŒ–'
            },
            en: {
                document_title: 'Game Tracker',
                title_main: 'ğŸ§® Game Tracker',
                section_current_scores: 'Current Scores',
                label_riichi_sticks_prefix: 'Riichi Sticks',
                label_riichi_sticks_suffix: '',
                game_end_title: 'ğŸ† Game Finished ğŸ†',
                section_record_win: 'Record Winning Hand',
                label_winner: 'Winner',
                label_loser: 'Loser (select "Tsumo" for self-draw)',
                option_tsumo: 'tsumo',
                label_choose_yaku: 'Select Yaku',
                placeholder_yaku_search: 'Type to search or choose from list...',
                button_add_yaku: 'Add',
                selected_yaku_placeholder: 'Please select yaku...',
                label_dora: 'Dora',
                label_aka_dora: 'Red Dora',
                label_ura_dora: 'Ura Dora',
                label_fu: 'Fu',
                option_fu: '{value} Fu',
                option_fu_25: '25 Fu (Seven Pairs)',
                label_menzen: 'Closed',
                preview_title: 'Preview',
                label_riichi_status: 'Riichi Status (check riichi players)',
                label_tenpai_players: 'Tenpai Players (check players who are tenpai)',
                button_record_win: 'Record Win',
                button_record_ryuukyoku: 'Record Draw',
                section_record_ryuukyoku: 'Record Draw',
                section_history: 'Game History',
                button_clear_history: 'Clear History',
                button_redo: 'Redo',
                history_empty: 'No records yet',
                undo_button: 'Undo',
                section_json: 'Game Data (JSON)',
                button_copy: 'Copy Data',
                button_import: 'Import Data',
                table_rank: 'Rank',
                table_player: 'Player',
                table_final_score: 'Final Score',
                table_raw_score: 'Raw Score',
                table_uma: 'Uma',
                table_riichi: 'Riichi Bonus',
                table_total: 'Total',
                rank_suffix: '',
                round_suffix: '',
                dealer_positions: ['East Seat', 'South Seat', 'West Seat', 'North Seat'],
                player_placeholder: 'Player {index}',
                copy_none: 'No data to copy',
                copy_failed: 'Copy failed: ',
                copy_auto: 'JSON copied automatically',
                copy_success: 'Copied to clipboard',
                copy_exec_failed: 'Unable to copy to clipboard',
                msg_enter_yaku: 'Please enter or select a yaku',
                msg_unrecognized_yaku: 'Unrecognized yaku: {name}',
                msg_duplicate_yaku: 'This yaku has already been added',
                msg_same_player: 'Winner and loser cannot be the same player.',
                msg_select_yaku_required: 'Please select at least one yaku.',
                msg_game_end: 'Game finished!',
                msg_record_success: 'Record saved!',
                msg_ryuukyoku_success: 'Draw recorded!',
                msg_ryuukyoku_success_end: 'Draw recorded! Game finished!',
                msg_no_history: 'No records to undo',
                msg_undo_success: 'Last record undone',
                msg_no_undo_stack: 'No records to redo',
                msg_redo_success: 'Record restored',
                msg_clear_confirm: 'Clear all records?',
                msg_history_cleared: 'History cleared',
                msg_switch_rule_disabled: 'Cannot switch rules during a game. Please clear the history first.',
                round_names: ['East', 'South', 'West', 'North'],
                honba_suffix: ' honba',
                dealer_label: 'Dealer',
                ron_text: 'Ron',
                tsumo_text: 'Self-draw',
                total_han: 'Total Han',
                han_unit: ' han',
                fu_unit: ' fu',
                dealer_tsumo_points: 'Dealer self-draw: {points} pts each',
                nondealer_tsumo_points: 'Non-dealer self-draw: others {small} pts, dealer {big} pts (total {total} pts)',
                dealer_ron_points: 'Dealer ron: {points} pts',
                nondealer_ron_points: 'Non-dealer ron: {points} pts',
                extra_points_header: 'Extra: ',
                extra_honba: 'Honba +{points} pts',
                extra_riichi: 'Riichi sticks +{points} pts',
                menzen_suffix_open: ' (Open)',
                riichi_players_label: 'Riichi',
                yaku_label: 'Yaku',
                dora_label_format: {
                    yaku: 'Yaku {han} han',
                    dora: 'Dora {count} han',
                    aka: 'Red {count} han',
                    ura: 'Ura {count} han'
                },
                history_ryuukyoku: 'Draw',
                history_continue: 'Dealer holds',
                history_change: 'Dealer passes',
                history_tenpai_prefix: 'Tenpai: ',
                history_all_tenpai: 'All tenpai',
                history_all_noten: 'No one tenpai',
                history_winner_summary: '{winner} wins ({han} han {fu} fu{dealer})',
                history_dealer_suffix: ' Dealer',
                history_loser_summary: '{loser}: {points}',
                history_tsumo_summary: 'Self-draw: {points}',
                history_extra_separator: ' Â· ',
                summary_note_ron: 'Ron',
                summary_note_tsumo: 'Self-draw',
                json_copy_button: 'Copy Data',
                history_score_changes: 'Score Changes',
                history_riichi_changes: 'Riichi Sticks'
            }
        };

        function t(key, params = {}) {
            const langTable = I18N[LANGUAGE] || {};
            const fallbackTable = I18N.zh || {};
            let template = langTable[key];
            if (template === undefined) {
                template = fallbackTable[key];
            }
            if (typeof template === 'object') {
                return template;
            }
            if (typeof template !== 'string') {
                return key;
            }
            return template.replace(/\{(\w+)\}/g, (_, k) => {
                return params[k] !== undefined ? params[k] : `{${k}}`;
            });
        }

        function applyTranslations() {
            document.title = t('document_title');
            document.documentElement.lang = LANGUAGE === 'en' ? 'en' : 'zh-CN';

            document.querySelectorAll('.language-switcher a').forEach(link => {
                const linkLang = link.dataset.lang;
                if (linkLang) {
                    link.classList.toggle('active', linkLang === LANGUAGE);
                }
            });

            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (!key) return;
                const value = t(key);
                if (value !== undefined) {
                    el.innerHTML = value;
                }
            });

            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (!key) return;
                const value = t(key);
                if (value !== undefined) {
                    el.setAttribute('placeholder', value);
                }
            });

            document.querySelectorAll('[data-i18n-option]').forEach(option => {
                const value = option.getAttribute('data-i18n-option');
                if (!value) return;
                if (value === 'fu_value') {
                    const fu = option.value;
                    option.textContent = fu === '25'
                        ? t('option_fu_25')
                        : t('option_fu', { value: fu });
                } else {
                    option.textContent = t(value);
                }
            });

            const copyBtn = document.getElementById('copy-game-summary');
            if (copyBtn) {
                copyBtn.textContent = t('button_copy');
            }

            const importBtn = document.getElementById('import-game-data');
            if (importBtn) {
                importBtn.textContent = t('button_import');
            }

            const gameEndTitle = document.querySelector('#game-end-notice h3');
            if (gameEndTitle) {
                gameEndTitle.innerHTML = t('game_end_title');
            }
        }

        function getDefaultPlayerName(index) {
            return t('player_placeholder', { index: index + 1 });
        }

        function getRiichiKeyword() {
            return LANGUAGE === 'en' ? 'riichi' : 'ç«‹ç›´';
        }
        // è®¡ç®—å½¹ç§æ€»ç•ªæ•°
        function calculateHanFromYaku(yakuText, isMenzen = true, doraCount = 0, akaDoraCount = 0, uraDoraCount = 0) {
            if (!yakuText || yakuText.trim() === '') {
                return {
                    totalHan: doraCount + akaDoraCount + uraDoraCount,
                    yakuHan: 0,
                    recognizedYaku: [],
                    unrecognizedYaku: [],
                    doraCount,
                    akaDoraCount,
                    uraDoraCount
                };
            }

            const yakuList = yakuText.trim().split(/\s+/);
            let yakuHan = 0;
            const recognizedYaku = [];
            const unrecognizedYaku = [];

            yakuList.forEach(yaku => {
                const yakuLower = yaku.toLowerCase();
                let han = 0;

                if (yakuDatabase[yakuLower] !== undefined) {
                    han = yakuDatabase[yakuLower];
                    recognizedYaku.push(yaku);
                } else if (yakuDatabase[yaku] !== undefined) {
                    han = yakuDatabase[yaku];
                    recognizedYaku.push(yaku);
                } else {
                    unrecognizedYaku.push(yaku);
                    return;
                }

                // å¦‚æœä¸æ˜¯é—¨æ¸…ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦å‡å°‘ç•ªæ•°
                if (!isMenzen) {
                    if (fuuroReducedYaku[yakuLower] !== undefined) {
                        han += fuuroReducedYaku[yakuLower];
                    } else if (fuuroReducedYaku[yaku] !== undefined) {
                        han += fuuroReducedYaku[yaku];
                    }
                }

                yakuHan += han;
            });

            const totalHan = yakuHan + doraCount + akaDoraCount + uraDoraCount;

            return { totalHan, yakuHan, recognizedYaku, unrecognizedYaku, doraCount, akaDoraCount, uraDoraCount };
        }

        // è·å–åˆå§‹ç‚¹æ•°
        function getInitialScore(rule) {
            return rule === 'wrc' ? 30000 : 25000;
        }

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            players: ['', '', '', ''],
            scores: [25000, 25000, 25000, 25000],
            rule: 'mleague',
            round: 0,  // å½“å‰å±€æ•° (0-based, 0=ä¸œ1, 1=ä¸œ2, ..., 4=å—1, etc.)
            dealer: 0, // å½“å‰åº„å®¶ä½ç½® (0-3)
            honba: 0,  // æœ¬åœºæ•°ï¼ˆè¿åº„æ¬¡æ•°ï¼‰
            riichiSticks: 0, // ç«‹ç›´æ£’æ•°é‡
            history: [],
            undoStack: [], // æ’¤é”€å†å²æ ˆï¼Œå­˜å‚¨è¢«æ’¤é”€çš„è®°å½•
            gameEnded: false // å¯¹å±€æ˜¯å¦ç»“æŸ
        };

        // æ£€æŸ¥å¯¹å±€æ˜¯å¦ç»“æŸï¼ˆå—4å±€ç»“æŸï¼‰
        function checkGameEnd(isDealer, dealerWon) {
            // å—4å±€ = round 7ï¼ˆ0=ä¸œ1, 1=ä¸œ2, 2=ä¸œ3, 3=ä¸œ4, 4=å—1, 5=å—2, 6=å—3, 7=å—4ï¼‰
            if (gameState.round === 7) {
                // å¦‚æœä¸æ˜¯åº„å®¶å’Œç‰Œ/å¬ç‰Œï¼Œå¯¹å±€ç»“æŸ
                if (!isDealer || !dealerWon) {
                    return true;
                }
            }
            return false;
        }

        // è®¡ç®—æœ€ç»ˆç»“ç®—
        function calculateFinalResults() {
            const initialScore = getInitialScore(gameState.rule);

            // è®¡ç®—æ’å
            const playerResults = gameState.players.map((name, index) => ({
                index,
                name: name || getDefaultPlayerName(index),
                finalScore: gameState.scores[index],
                rawScore: gameState.scores[index] - initialScore // ç´ ç‚¹å·®
            }));

            // æŒ‰åˆ†æ•°æ’åº
            playerResults.sort((a, b) => b.finalScore - a.finalScore);

            // åˆ†é…æ’åï¼ˆå¤„ç†åŒåˆ†æƒ…å†µï¼‰
            let currentRank = 1;
            for (let i = 0; i < playerResults.length; i++) {
                if (i > 0 && playerResults[i].finalScore < playerResults[i-1].finalScore) {
                    currentRank = i + 1;
                }
                playerResults[i].rank = currentRank;
            }

            // ä¸€ä½è·å¾—æ‰€æœ‰ç«‹ç›´æ£’
            const riichiBonus = gameState.riichiSticks * 1000;

            // è®¡ç®—é©¬ç‚¹
            const umaPoints = gameState.rule === 'mleague'
                ? [45000, 5000, -15000, -35000]  // M-League
                : [30000, 10000, -10000, -30000]; // WRC

            playerResults.forEach((player, index) => {
                player.uma = umaPoints[index];
                player.riichiBonus = (index === 0) ? riichiBonus : 0; // ä¸€ä½è·å¾—ç«‹ç›´æ£’
                player.totalScore = player.rawScore + player.uma + player.riichiBonus;
            });

            return playerResults;
        }

        // å½“å‰é€‰æ‹©çš„å½¹ç§
        let selectedYaku = [];
        let lastCopiedSummary = '';
        let copyStatusTimeout = null;

        // è·å–æ‰€æœ‰å½¹ç§çš„åç§°åˆ—è¡¨ï¼ˆç”¨äºdatalistï¼‰
        function getAllYakuNames() {
            const yakuNames = new Set();
            for (const key in yakuDatabase) {
                yakuNames.add(key);
            }

            // åˆ†ç±»ï¼šä¸­æ–‡ã€æ—¥æ–‡ã€ç½—é©¬éŸ³
            const chineseNames = [];
            const japaneseNames = [];
            const romajiNames = [];

            Array.from(yakuNames).forEach(name => {
                const firstChar = name.charCodeAt(0);
                // ä¸­æ–‡èŒƒå›´ï¼š0x4E00-0x9FFF
                if (firstChar >= 0x4E00 && firstChar <= 0x9FFF) {
                    chineseNames.push(name);
                }
                // æ—¥æ–‡å‡åèŒƒå›´ï¼š0x3040-0x30FF
                else if (firstChar >= 0x3040 && firstChar <= 0x30FF) {
                    japaneseNames.push(name);
                }
                // ç½—é©¬éŸ³ï¼ˆè‹±æ–‡å­—æ¯ï¼‰
                else {
                    romajiNames.push(name);
                }
            });

            // åˆ†åˆ«æ’åºååˆå¹¶ï¼šä¸­æ–‡ -> ç½—é©¬éŸ³ -> æ—¥æ–‡
            chineseNames.sort();
            romajiNames.sort();
            japaneseNames.sort();

            if (LANGUAGE === 'en') {
                return [...romajiNames, ...chineseNames, ...japaneseNames];
            }
            return [...chineseNames, ...romajiNames, ...japaneseNames];
        }

        // å¡«å……å½¹ç§datalist
        function populateYakuDatalist() {
            const datalist = document.getElementById('yaku-datalist');
            const yakuNames = getAllYakuNames();

            datalist.innerHTML = '';
            yakuNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                datalist.appendChild(option);
            });
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯ç«‹ç›´ç›¸å…³å½¹ç§
        function isRiichiYaku(yakuName) {
            const riichiYaku = [
                'ç«‹ç›´', 'riichi', 'ãƒªãƒ¼ãƒ',
                'åŒç«‹ç›´', 'åŒç«‹', 'daburu riichi', 'ãƒ€ãƒ–ãƒ«ãƒªãƒ¼ãƒ', 'wç«‹ç›´'
            ];
            return riichiYaku.some(y => yakuName.toLowerCase() === y.toLowerCase() || yakuName === y);
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦ç«‹ç›´çš„å½¹ç§
        function needsRiichi(yakuName) {
            const needsRiichiYaku = [
                'ä¸€å‘', 'ippatsu', 'ã‚¤ãƒƒãƒ‘ãƒ„',
                'é—¨å‰æ¸…è‡ªæ‘¸å’Œ', 'é—¨æ¸…', 'tsumo', 'ãƒ„ãƒ¢'
            ];
            return needsRiichiYaku.some(y => yakuName.toLowerCase() === y.toLowerCase() || yakuName === y);
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸ƒå¯¹å­
        function isSevenPairsYaku(yakuName) {
            const normalized = yakuName.trim();
            const lower = normalized.toLowerCase();
            const variants = ['ä¸ƒå¯¹å­', 'ä¸ƒå¯¹', 'chiitoitsu', 'ãƒãƒ¼ãƒˆã‚¤ãƒ„'];
            return variants.some(variant => normalized === variant || lower === variant.toLowerCase());
        }

        // æ ¹æ®å½“å‰å½¹ç§æ›´æ–°é—¨æ¸…å’Œç¬¦æ•°é”å®šçŠ¶æ€
        function updateLocks() {
            const menzenCheckbox = document.getElementById('menzen');
            const fuSelect = document.getElementById('fu');
            if (!menzenCheckbox || !fuSelect) return;

            const hasRiichi = selectedYaku.some(y => isRiichiYaku(y));
            const hasNeedsRiichi = selectedYaku.some(y => needsRiichi(y));
            const hasSevenPairs = selectedYaku.some(y => isSevenPairsYaku(y));

            if (hasSevenPairs) {
                fuSelect.value = '25';
                fuSelect.disabled = true;
            } else {
                fuSelect.disabled = false;
            }

            if (hasRiichi || hasNeedsRiichi || hasSevenPairs) {
                menzenCheckbox.checked = true;
                menzenCheckbox.disabled = true;
            } else {
                menzenCheckbox.disabled = false;
            }

            if (hasRiichi || hasNeedsRiichi) {
                const winnerInput = document.getElementById('winner');
                if (winnerInput) {
                    const winnerId = parseInt(winnerInput.value);
                    if (!Number.isNaN(winnerId)) {
                        const riichiCheckbox = document.getElementById(`riichi-${winnerId}`);
                        if (riichiCheckbox) {
                            riichiCheckbox.checked = true;
                        }
                    }
                }
            }
        }

        // æ·»åŠ å½¹ç§
        function addYaku() {
            const input = document.getElementById('yaku-search');
            const yakuName = input.value.trim();

            if (!yakuName) {
                showMessage(t('msg_enter_yaku'), 'error');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦åœ¨æ•°æ®åº“ä¸­
            const yakuLower = yakuName.toLowerCase();
            if (yakuDatabase[yakuLower] === undefined && yakuDatabase[yakuName] === undefined) {
                showMessage(t('msg_unrecognized_yaku', { name: yakuName }), 'error');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦å·²ç»æ·»åŠ 
            if (selectedYaku.includes(yakuName)) {
                showMessage(t('msg_duplicate_yaku'), 'error');
                return;
            }

            selectedYaku.push(yakuName);

            // å¦‚æœæ·»åŠ çš„æ˜¯ä¸€å‘æˆ–é—¨æ¸…è‡ªæ‘¸ï¼Œè‡ªåŠ¨æ·»åŠ ç«‹ç›´
            if (needsRiichi(yakuName)) {
                const hasRiichi = selectedYaku.some(y => isRiichiYaku(y));
                if (!hasRiichi) {
                    selectedYaku.push(getRiichiKeyword());
                }
            }

            updateLocks();
            input.value = '';
            updateSelectedYakuDisplay();
            updateYakuPreview();
        }

        // ç§»é™¤å½¹ç§
        function removeYaku(yakuName) {
            const index = selectedYaku.indexOf(yakuName);
            if (index > -1) {
                selectedYaku.splice(index, 1);

                updateLocks();
                updateSelectedYakuDisplay();
                updateYakuPreview();
            }
        }

        // æ›´æ–°å·²é€‰æ‹©å½¹ç§çš„æ˜¾ç¤º
        function updateSelectedYakuDisplay() {
            const container = document.getElementById('selected-yaku-list');

            if (selectedYaku.length === 0) {
                container.innerHTML = `<div style="color: #999;">${t('selected_yaku_placeholder')}</div>`;
                return;
            }

            const isMenzen = document.getElementById('menzen') ? document.getElementById('menzen').checked : true;

            container.innerHTML = selectedYaku.map(yaku => {
                let han = yakuDatabase[yaku] || yakuDatabase[yaku.toLowerCase()] || 0;

                // å¦‚æœä¸æ˜¯é—¨æ¸…ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦å‡å°‘ç•ªæ•°
                if (!isMenzen) {
                    const yakuLower = yaku.toLowerCase();
                    if (fuuroReducedYaku[yakuLower] !== undefined) {
                        han += fuuroReducedYaku[yakuLower];
                    } else if (fuuroReducedYaku[yaku] !== undefined) {
                        han += fuuroReducedYaku[yaku];
                    }
                }

                const encodedYaku = encodeURIComponent(yaku);
                return `
                    <span class="yaku-tag">
                        ${yaku} (${han}${t('han_unit')})
                        <button type="button" class="remove-yaku-btn" data-yaku="${encodedYaku}">Ã—</button>
                    </span>
                `;
            }).join('');
        }

        // åˆå§‹åŒ–
        function init() {
            applyTranslations();
            loadState();
            populateYakuDatalist();
            updateDisplay();
            setupEventListeners();
            setupYakuInputListener();
            setupActionButtons();
        }

        // æ›´æ–°å½¹ç§é¢„è§ˆ
        function updateYakuPreview() {
            const fu = parseInt(document.getElementById('fu').value);
            const winnerId = parseInt(document.getElementById('winner').value) || 0;
            const loserValue = document.getElementById('loser').value;
            const menzenCheckbox = document.getElementById('menzen');
            let isMenzen = menzenCheckbox.checked;
            const isDealer = winnerId === gameState.dealer;
            const isTsumo = loserValue === 'tsumo';

            // è·å–å®ç‰Œæ•°é‡
            const doraCount = parseInt(document.getElementById('dora-count').value) || 0;
            const akaDoraCount = parseInt(document.getElementById('aka-dora-count').value) || 0;
            const uraDoraCount = parseInt(document.getElementById('ura-dora-count').value) || 0;

            // é‡Œå®å­˜åœ¨æ—¶è‡ªåŠ¨æ·»åŠ ç«‹ç›´ï¼ˆè‹¥å°šæœªæ·»åŠ ï¼‰
            if (uraDoraCount > 0 && !selectedYaku.some(y => isRiichiYaku(y))) {
                selectedYaku.push(getRiichiKeyword());
                updateLocks();
                updateSelectedYakuDisplay();
                isMenzen = menzenCheckbox.checked;
            }

            if (selectedYaku.length === 0 && doraCount === 0 && akaDoraCount === 0 && uraDoraCount === 0) {
                document.getElementById('yaku-preview').style.display = 'none';
                return;
            }

            const yakuText = selectedYaku.join(' ');
            const result = calculateHanFromYaku(yakuText, isMenzen, doraCount, akaDoraCount, uraDoraCount);
            const previewDiv = document.getElementById('yaku-preview');
            previewDiv.style.display = 'block';

            // éšè—è¯†åˆ«/æœªè¯†åˆ«æ–‡æœ¬ï¼ˆå› ä¸ºç”¨æˆ·æ˜¯ä»åˆ—è¡¨é€‰æ‹©çš„ï¼‰
            document.getElementById('yaku-recognized').textContent = '';
            document.getElementById('yaku-unrecognized').textContent = '';

            // æ˜¾ç¤ºæ€»ç•ªæ•°
            const menzenText = isMenzen ? '' : t('menzen_suffix_open');
            let hanText = `${t('total_han')}: ${result.totalHan}${t('han_unit')}${menzenText}`;

            // æ˜¾ç¤ºå®ç‰Œè¯¦æƒ…
            const doraDetails = [];
            if (result.yakuHan > 0) doraDetails.push(LANGUAGE === 'en'
                ? `Yaku ${result.yakuHan}${t('han_unit')}`
                : `å½¹${result.yakuHan}ç•ª`);
            if (doraCount > 0) doraDetails.push(LANGUAGE === 'en'
                ? `Dora ${doraCount}${t('han_unit')}`
                : `å®ç‰Œ${doraCount}ç•ª`);
            if (akaDoraCount > 0) doraDetails.push(LANGUAGE === 'en'
                ? `Red ${akaDoraCount}${t('han_unit')}`
                : `èµ¤${akaDoraCount}ç•ª`);
            if (uraDoraCount > 0) doraDetails.push(LANGUAGE === 'en'
                ? `Ura ${uraDoraCount}${t('han_unit')}`
                : `é‡Œ${uraDoraCount}ç•ª`);

            if (doraDetails.length > 0) {
                hanText += ` (${doraDetails.join(' + ')})`;
            }

            document.getElementById('yaku-han').textContent = hanText;

            // è®¡ç®—ç‚¹æ•°
            const points = calculatePoints(result.totalHan, fu, isDealer, isTsumo, gameState.rule);
            let pointsText = '';
            if (isTsumo) {
                if (isDealer) {
                    pointsText = t('dealer_tsumo_points', { points: points[0] });
                } else {
                    pointsText = t('nondealer_tsumo_points', { small: points[0], big: points[1], total: points[0]*2 + points[1] });
                }
            } else {
                pointsText = isDealer
                    ? t('dealer_ron_points', { points })
                    : t('nondealer_ron_points', { points });
            }

            // æ·»åŠ æœ¬åœºå’Œç«‹ç›´æ£’ä¿¡æ¯
            const honbaPoints = gameState.honba * 300;
            const riichiPoints = gameState.riichiSticks * 1000;
            if (honbaPoints > 0 || riichiPoints > 0) {
                pointsText += `\n${t('extra_points_header')}`;
                if (honbaPoints > 0) pointsText += `${t('extra_honba', { points: honbaPoints })} `;
                if (riichiPoints > 0) pointsText += t('extra_riichi', { points: riichiPoints });
            }

            document.getElementById('yaku-points').textContent = pointsText;
            document.getElementById('yaku-points').style.whiteSpace = 'pre-line';
        }

        // è®¾ç½®å½¹ç§è¾“å…¥ç›‘å¬å™¨
        function setupYakuInputListener() {
            const yakuSearch = document.getElementById('yaku-search');
            const fuSelect = document.getElementById('fu');
            const winnerSelect = document.getElementById('winner');
            const loserSelect = document.getElementById('loser');
            const menzenCheckbox = document.getElementById('menzen');
            const doraCount = document.getElementById('dora-count');
            const akaDoraCount = document.getElementById('aka-dora-count');
            const uraDoraCount = document.getElementById('ura-dora-count');

            // æ”¯æŒEnteré”®æ·»åŠ 
            yakuSearch.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addYaku();
                }
            });

            // å½“é€‰æ‹©æ”¹å˜æ—¶æ›´æ–°é¢„è§ˆ
            fuSelect.addEventListener('change', updateYakuPreview);
            winnerSelect.addEventListener('change', () => {
                updateLocks();
                updateYakuPreview();
            });
            loserSelect.addEventListener('change', updateYakuPreview);
            menzenCheckbox.addEventListener('change', () => {
                updateSelectedYakuDisplay(); // æ›´æ–°å½¹ç§æ ‡ç­¾çš„ç•ªæ•°
                updateYakuPreview();
            });

            // å®ç‰Œæ•°é‡æ”¹å˜æ—¶æ›´æ–°é¢„è§ˆ
            doraCount.addEventListener('input', updateYakuPreview);
            akaDoraCount.addEventListener('input', updateYakuPreview);
            uraDoraCount.addEventListener('input', updateYakuPreview);
        }

        function setupActionButtons() {
            const addBtn = document.getElementById('add-yaku-btn');
            if (addBtn) {
                addBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    addYaku();
                });
            }

            const recordWinBtn = document.getElementById('record-win-btn');
            if (recordWinBtn) {
                recordWinBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    recordWin();
                });
            }

            const recordRyuukyokuBtn = document.getElementById('record-ryuukyoku-btn');
            if (recordRyuukyokuBtn) {
                recordRyuukyokuBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    recordRyuukyoku();
                });
            }

            const clearHistoryBtn = document.getElementById('clear-history-btn');
            if (clearHistoryBtn) {
                clearHistoryBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    clearHistory();
                });
            }

            const redoBtn = document.getElementById('redo-btn');
            if (redoBtn) {
                redoBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    redoLast();
                });
            }

            const selectedYakuList = document.getElementById('selected-yaku-list');
            if (selectedYakuList) {
                selectedYakuList.addEventListener('click', (event) => {
                    const btn = event.target.closest('.remove-yaku-btn');
                    if (btn && btn.dataset.yaku) {
                        removeYaku(decodeURIComponent(btn.dataset.yaku));
                    }
                });
            }

            const historyDiv = document.getElementById('history');
            if (historyDiv) {
                historyDiv.addEventListener('click', (event) => {
                    const btn = event.target.closest('.undo-last-btn');
                    if (btn) {
                        event.preventDefault();
                        undoLast();
                    }
                });
            }
        }

        // æ›´æ–°ç©å®¶åå­—
        function updatePlayerName(index, name) {
            gameState.players[index] = name;
            saveState();
            updateDisplay();
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // è§„åˆ™é€‰æ‹©
            document.querySelectorAll('.rule-btn-compact').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // å¦‚æœæœ‰å†å²è®°å½•ï¼Œç¦æ­¢åˆ‡æ¢è§„åˆ™
                    if (gameState.history.length > 0) {
                        showMessage(t('msg_switch_rule_disabled'), 'error');
                        return;
                    }

                    const newRule = e.target.dataset.rule;

                    // å¦‚æœåˆ‡æ¢è§„åˆ™ï¼Œæ›´æ–°åˆå§‹ç‚¹æ•°
                    if (gameState.rule !== newRule) {
                        const initialScore = getInitialScore(newRule);
                        gameState.scores = [initialScore, initialScore, initialScore, initialScore];
                    }

                    document.querySelectorAll('.rule-btn-compact').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    gameState.rule = newRule;
                    saveState();
                    updateDisplay();
                });
            });

            // æµå±€ç•Œé¢ï¼šç«‹ç›´è‡ªåŠ¨å‹¾é€‰å¬ç‰Œ
            for (let i = 0; i < 4; i++) {
                const riichiCheckbox = document.getElementById(`ryuukyoku-riichi-${i}`);
                const tenpaiCheckbox = document.getElementById(`tenpai-${i}`);
                if (!riichiCheckbox || !tenpaiCheckbox) continue;
                riichiCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        tenpaiCheckbox.checked = true;
                    }
                });
            }

            const copyBtn = document.getElementById('copy-game-summary');
            if (copyBtn) {
                copyBtn.addEventListener('click', () => copyGameSummary(false));
            }

            const importBtn = document.getElementById('import-game-data');
            if (importBtn) {
                importBtn.addEventListener('click', () => importGameData());
            }
        }

        // æ˜¾ç¤ºæœ€ç»ˆç»“ç®—
        function showFinalResults() {
            const results = calculateFinalResults();
            const finalResultsDiv = document.getElementById('final-results');

            let html = '<table style="width: 100%; border-collapse: collapse; background: white; border-radius: 5px; overflow: hidden;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += `<th style="padding: 10px;">${t('table_rank')}</th>`;
            html += `<th style="padding: 10px;">${t('table_player')}</th>`;
            html += `<th style="padding: 10px;">${t('table_final_score')}</th>`;
            html += `<th style="padding: 10px;">${t('table_raw_score')}</th>`;
            html += `<th style="padding: 10px;">${t('table_uma')}</th>`;
            html += `<th style="padding: 10px;">${t('table_riichi')}</th>`;
            html += `<th style="padding: 10px;">${t('table_total')}</th>`;
            html += '</tr></thead><tbody>';

            results.forEach((player, index) => {
                const rankEmoji = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ï¸âƒ£'][index] || '';
                const rowColor = index % 2 === 0 ? '#f8f9fa' : 'white';
                html += `<tr style="background: ${rowColor}; text-align: center;">`;
                html += `<td style="padding: 10px; font-size: 1.2em;">${rankEmoji} ${player.rank}${t('rank_suffix')}</td>`;
                html += `<td style="padding: 10px; font-weight: bold;">${player.name}</td>`;
                html += `<td style="padding: 10px;">${player.finalScore.toLocaleString()}</td>`;
                html += `<td style="padding: 10px; color: ${player.rawScore >= 0 ? '#28a745' : '#dc3545'};">${player.rawScore >= 0 ? '+' : ''}${player.rawScore.toLocaleString()}</td>`;
                html += `<td style="padding: 10px; color: ${player.uma >= 0 ? '#28a745' : '#dc3545'};">${player.uma >= 0 ? '+' : ''}${player.uma.toLocaleString()}</td>`;
                html += `<td style="padding: 10px; color: ${player.riichiBonus > 0 ? '#28a745' : '#666'};">${player.riichiBonus > 0 ? '+' : ''}${player.riichiBonus.toLocaleString()}</td>`;
                html += `<td style="padding: 10px; font-weight: bold; font-size: 1.1em; color: ${player.totalScore >= 0 ? '#28a745' : '#dc3545'};">${player.totalScore >= 0 ? '+' : ''}${player.totalScore.toLocaleString()}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            finalResultsDiv.innerHTML = html;
            document.getElementById('game-end-notice').style.display = 'block';
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay() {
            // æ›´æ–°å±€æ•°æ˜¾ç¤º
            const roundNames = t('round_names');
            const roundIndex = Math.floor(gameState.round / 4);
            const subRound = (gameState.round % 4) + 1;
            let roundName;
            if (LANGUAGE === 'en') {
                roundName = `${roundNames[roundIndex % 4]} ${subRound}`;
            } else {
                roundName = `${roundNames[roundIndex % 4]}${subRound}${t('round_suffix')}`;
            }
            document.getElementById('current-round').textContent = roundName;

            // æ›´æ–°æœ¬åœºæ•°æ˜¾ç¤ºï¼ˆå¯¹å±€ç»“æŸåä¸æ˜¾ç¤ºï¼‰
            const honbaElement = document.getElementById('honba-display');
            if (gameState.gameEnded) {
                honbaElement.style.display = 'none';
            } else {
                honbaElement.style.display = 'inline';
                honbaElement.textContent = `${gameState.honba}${t('honba_suffix')}`;
            }

            // æ›´æ–°ç«‹ç›´æ£’æ˜¾ç¤º
            document.getElementById('riichi-sticks').textContent = `${gameState.riichiSticks}`;

            // æ›´æ–°ç‚¹æ•°æ˜¾ç¤º
            const scoresDiv = document.getElementById('scores-display');
            scoresDiv.innerHTML = '';
            const positions = t('dealer_positions');
            gameState.players.forEach((name, i) => {
                const isDealer = i === gameState.dealer;
                const dealerClass = isDealer ? 'dealer' : '';
                const dealerBadge = isDealer ? ' ğŸ€„' : '';
                scoresDiv.innerHTML += `
                    <div class="player-score ${dealerClass}">
                        <input type="text"
                               id="player-name-${i}"
                               value="${name}"
                               placeholder="${positions[i] || getDefaultPlayerName(i)}"
                               onchange="updatePlayerName(${i}, this.value)"
                               ${gameState.gameEnded ? 'disabled' : ''}>
                        <div class="score">${gameState.scores[i].toLocaleString()}${dealerBadge}</div>
                    </div>
                `;
            });

            // æ£€æŸ¥å¯¹å±€æ˜¯å¦ç»“æŸ
            if (gameState.gameEnded) {
                showFinalResults();
            } else {
                document.getElementById('game-end-notice').style.display = 'none';
            }

            // æ›´æ–°ç«‹ç›´å’Œå¬ç‰Œé€‰é¡¹çš„æ ‡ç­¾
            for (let i = 0; i < 4; i++) {
                const playerName = gameState.players[i] || getDefaultPlayerName(i);
                document.getElementById(`riichi-label-${i}`).textContent = playerName;
                document.getElementById(`tenpai-label-${i}`).textContent = playerName;
                document.getElementById(`ryuukyoku-riichi-label-${i}`).textContent = playerName;
            }

            // æ ¹æ®å†å²è®°å½•æ˜¯å¦å­˜åœ¨ï¼Œç¦ç”¨æˆ–å¯ç”¨è§„åˆ™æŒ‰é’®
            const hasHistory = gameState.history.length > 0;
            document.querySelectorAll('.rule-btn-compact').forEach(btn => {
                btn.disabled = hasHistory || gameState.gameEnded;
            });

            // æ›´æ–°ä¸‹æ‹‰é€‰é¡¹
            updateSelects();

            // æ›´æ–°å†å²è®°å½•
            updateHistory();

            // å¯¹å±€ç»“æŸåå°é”æ‰€æœ‰è¾“å…¥å’ŒæŒ‰é’®
            if (gameState.gameEnded) {
                // ç¦ç”¨å’Œç‰Œç›¸å…³çš„æ‰€æœ‰è¾“å…¥
                document.getElementById('winner').disabled = true;
                document.getElementById('loser').disabled = true;
                document.getElementById('fu').disabled = true;
                document.getElementById('menzen').disabled = true;
                document.getElementById('yaku-search').disabled = true;
                const addYakuButton = document.getElementById('add-yaku-btn');
                if (addYakuButton) addYakuButton.disabled = true;
                document.getElementById('dora-count').disabled = true;
                document.getElementById('aka-dora-count').disabled = true;
                document.getElementById('ura-dora-count').disabled = true;
                const recordWinButton = document.getElementById('record-win-btn');
                if (recordWinButton) recordWinButton.disabled = true;

                // ç¦ç”¨æµå±€ç›¸å…³çš„æ‰€æœ‰è¾“å…¥
                for (let i = 0; i < 4; i++) {
                    document.getElementById(`tenpai-${i}`).disabled = true;
                    document.getElementById(`ryuukyoku-riichi-${i}`).disabled = true;
                    document.getElementById(`riichi-${i}`).disabled = true;
                }
                const recordRyuukyokuButton = document.getElementById('record-ryuukyoku-btn');
                if (recordRyuukyokuButton) recordRyuukyokuButton.disabled = true;
            } else {
                // å¯ç”¨æ‰€æœ‰è¾“å…¥
                document.getElementById('winner').disabled = false;
                document.getElementById('loser').disabled = false;
                document.getElementById('fu').disabled = false;
                document.getElementById('menzen').disabled = false;
                document.getElementById('yaku-search').disabled = false;
                const addYakuButtonEnabled = document.getElementById('add-yaku-btn');
                if (addYakuButtonEnabled) addYakuButtonEnabled.disabled = false;
                document.getElementById('dora-count').disabled = false;
                document.getElementById('aka-dora-count').disabled = false;
                document.getElementById('ura-dora-count').disabled = false;
                const recordWinButtonEnabled = document.getElementById('record-win-btn');
                if (recordWinButtonEnabled) recordWinButtonEnabled.disabled = false;

                for (let i = 0; i < 4; i++) {
                    document.getElementById(`tenpai-${i}`).disabled = false;
                    document.getElementById(`ryuukyoku-riichi-${i}`).disabled = false;
                    document.getElementById(`riichi-${i}`).disabled = false;
                }
                const recordRyuukyokuButtonEnabled = document.getElementById('record-ryuukyoku-btn');
                if (recordRyuukyokuButtonEnabled) recordRyuukyokuButtonEnabled.disabled = false;
            }

            // Update redo button state
            const redoBtn = document.getElementById('redo-btn');
            if (redoBtn) {
                redoBtn.disabled = gameState.undoStack.length === 0;
            }

            if (!gameState.gameEnded) {
                updateLocks();
            }

            updateGameSummary();
        }

        // æ›´æ–°ä¸‹æ‹‰é€‰é¡¹
        function updateSelects() {
            const winnerSelect = document.getElementById('winner');
            const loserSelect = document.getElementById('loser');

            winnerSelect.innerHTML = '';
            loserSelect.innerHTML = `<option value="tsumo">${t('option_tsumo')}</option>`;

            gameState.players.forEach((name, i) => {
                const playerName = name || getDefaultPlayerName(i);
                winnerSelect.innerHTML += `<option value="${i}">${playerName}</option>`;
                loserSelect.innerHTML += `<option value="${i}">${playerName}</option>`;
            });
        }

        // è®¡ç®—ç‚¹æ•°
        function calculatePoints(han, fu, isDealer, isTsumo, rule) {
            // å½¹æ»¡åŠä»¥ä¸Š
            if (han >= 13) {
                return isDealer
                    ? (isTsumo ? [16000, 16000, 16000] : 48000)
                    : (isTsumo ? [8000, 16000, 8000] : 32000);
            }
            if (han >= 11) {
                return isDealer
                    ? (isTsumo ? [12000, 12000, 12000] : 36000)
                    : (isTsumo ? [6000, 12000, 6000] : 24000);
            }
            if (han >= 8) {
                return isDealer
                    ? (isTsumo ? [8000, 8000, 8000] : 24000)
                    : (isTsumo ? [4000, 8000, 4000] : 16000);
            }
            if (han >= 6) {
                return isDealer
                    ? (isTsumo ? [6000, 6000, 6000] : 18000)
                    : (isTsumo ? [3000, 6000, 3000] : 12000);
            }

            // è®¡ç®—åŸºæœ¬ç‚¹
            let basePoints = fu * Math.pow(2, 2 + han);

            // æ»¡è´¯åˆ¤å®šï¼ˆWRCå’ŒM-Leagueè§„åˆ™ä¸åŒï¼‰
            if (rule === 'wrc') {
                // WRCè§„åˆ™ï¼šåªæœ‰5ç•ªåŠä»¥ä¸Šï¼Œæˆ–4ç•ª40ç¬¦+ï¼Œæˆ–3ç•ª70ç¬¦+æ‰æ˜¯æ»¡è´¯
                if (han >= 5 || (han >= 4 && fu >= 40) || (han >= 3 && fu >= 70)) {
                    return isDealer
                        ? (isTsumo ? [4000, 4000, 4000] : 12000)
                        : (isTsumo ? [2000, 4000, 2000] : 8000);
                }
            } else {
                // M-Leagueè§„åˆ™ï¼š4ç•ª30ç¬¦ä¹ŸæŒ‰æ»¡è´¯è®¡ç®—
                if (han >= 5 || (han >= 4 && fu >= 30) || (han >= 3 && fu >= 70)) {
                    return isDealer
                        ? (isTsumo ? [4000, 4000, 4000] : 12000)
                        : (isTsumo ? [2000, 4000, 2000] : 8000);
                }
            }

            // æ™®é€šè®¡ç®—
            if (isTsumo) {
                if (isDealer) {
                    const payment = Math.ceil(basePoints * 2 / 100) * 100;
                    return [payment, payment, payment];
                } else {
                    const dealerPayment = Math.ceil(basePoints * 2 / 100) * 100;
                    const otherPayment = Math.ceil(basePoints / 100) * 100;
                    return [otherPayment, dealerPayment, otherPayment];
                }
            } else {
                if (isDealer) {
                    return Math.ceil(basePoints * 6 / 100) * 100;
                } else {
                    return Math.ceil(basePoints * 4 / 100) * 100;
                }
            }
        }

        // è®°å½•å’Œç‰Œ
        function recordWin() {
            const winnerId = parseInt(document.getElementById('winner').value);
            const loserValue = document.getElementById('loser').value;
            const fu = parseInt(document.getElementById('fu').value);
            const isMenzen = document.getElementById('menzen').checked;
            const isDealer = winnerId === gameState.dealer;  // è‡ªåŠ¨åˆ¤æ–­æ˜¯å¦åº„å®¶
            const isTsumo = loserValue === 'tsumo';
            const loserId = isTsumo ? -1 : parseInt(loserValue);
            const doraCount = parseInt(document.getElementById('dora-count').value) || 0;
            const akaDoraCount = parseInt(document.getElementById('aka-dora-count').value) || 0;
            const uraDoraCount = parseInt(document.getElementById('ura-dora-count').value) || 0;

            // éªŒè¯
            if (!isTsumo && winnerId === loserId) {
                showMessage(t('msg_same_player'), 'error');
                return;
            }

            // éªŒè¯å½¹ç§
            if (selectedYaku.length === 0) {
                showMessage(t('msg_select_yaku_required'), 'error');
                return;
            }

            // è®¡ç®—ç•ªæ•°
            const yakuText = selectedYaku.join(' ');
            const yakuResult = calculateHanFromYaku(
                yakuText,
                isMenzen,
                doraCount,
                akaDoraCount,
                uraDoraCount
            );
            const han = yakuResult.totalHan;

            // è·å–ç«‹ç›´æƒ…å†µ
            const riichiPlayers = [];
            for (let i = 0; i < 4; i++) {
                if (document.getElementById(`riichi-${i}`).checked) {
                    riichiPlayers.push(i);
                }
            }

            // è®¡ç®—åŸºæœ¬ç‚¹æ•°
            const points = calculatePoints(han, fu, isDealer, isTsumo, gameState.rule);
            const newScores = [...gameState.scores];

            // è®¡ç®—æœ¬åœºæ£’ç‚¹æ•°
            const honbaPoints = gameState.honba * 300;

            if (isTsumo) {
                // è‡ªæ‘¸
                const [pay0, pay1, pay2] = points;
                newScores.forEach((score, i) => {
                    if (i !== winnerId) {
                        if (i === 0) {
                            newScores[i] -= pay1;
                            newScores[winnerId] += pay1;
                        } else {
                            const payment = isDealer ? pay0 : (winnerId === 0 ? pay1 : pay0);
                            newScores[i] -= payment;
                            newScores[winnerId] += payment;
                        }
                    }
                });
                // è‡ªæ‘¸æ—¶ï¼Œæœ¬åœºæ£’ç”±å…¶ä»–ä¸‰å®¶å¹³åˆ†æ”¯ä»˜
                const honbaPerPlayer = Math.floor(honbaPoints / 3);
                newScores.forEach((score, i) => {
                    if (i !== winnerId) {
                        newScores[i] -= honbaPerPlayer;
                        newScores[winnerId] += honbaPerPlayer;
                    }
                });
            } else {
                // ç‚¹ç‚®
                newScores[loserId] -= points;
                newScores[winnerId] += points;
                // ç‚¹ç‚®æ—¶ï¼Œæœ¬åœºæ£’ç”±ç‚¹ç‚®è€…æ”¯ä»˜
                newScores[loserId] -= honbaPoints;
                newScores[winnerId] += honbaPoints;
            }

            // æ‰£é™¤ç«‹ç›´ç©å®¶çš„1000ç‚¹
            riichiPlayers.forEach(playerId => {
                newScores[playerId] -= 1000;
            });

            // ç«‹ç›´æ£’ç”±å’Œç‰Œè€…æ”¶å–ï¼ˆåŒ…æ‹¬ä¹‹å‰ç§¯ç´¯çš„ç«‹ç›´æ£’ + æœ¬å±€æ–°å¢çš„ç«‹ç›´æ£’ï¼‰
            const totalRiichiSticks = gameState.riichiSticks + riichiPlayers.length;
            const totalRiichiPoints = totalRiichiSticks * 1000;
            newScores[winnerId] += totalRiichiPoints;

            // è®°å½•å†å²
            const record = {
                type: 'win',
                winnerId,
                loserId,
                isTsumo,
                han,
                fu,
                yaku: yakuResult.recognizedYaku.join(' '),
                yakuHan: yakuResult.yakuHan,
                doraCount: yakuResult.doraCount,
                akaDoraCount: yakuResult.akaDoraCount,
                uraDoraCount: yakuResult.uraDoraCount,
                isMenzen,
                isDealer,
                points,
                riichiPlayers: [...riichiPlayers],
                honbaPoints,
                riichiPoints: totalRiichiPoints,
                scoreBefore: [...gameState.scores],
                scoreAfter: [...newScores],
                roundBefore: gameState.round,
                dealerBefore: gameState.dealer,
                honbaBefore: gameState.honba,
                riichiSticksBefore: gameState.riichiSticks,
                riichiSticksAfter: 0,
                timestamp: Date.now()
            };

            gameState.history.push(record);
            gameState.scores = newScores;

            // æ¸…ç©ºæ’¤é”€æ ˆï¼ˆæ–°æ“ä½œä¼šä½¿ä¹‹å‰çš„æ’¤é”€æ— æ•ˆï¼‰
            gameState.undoStack = [];

            // æ›´æ–°ç«‹ç›´æ£’æ•°é‡ï¼ˆå’Œç‰Œåæ‰€æœ‰ç«‹ç›´æ£’è¢«å’Œç‰Œè€…æ‹¿èµ°ï¼Œæ¸…é›¶ï¼‰
            gameState.riichiSticks = 0;

            // æ£€æŸ¥å¯¹å±€æ˜¯å¦ç»“æŸ
            if (checkGameEnd(isDealer, true)) {
                gameState.gameEnded = true;
            }

            // æ›´æ–°åº„å®¶å’Œå±€æ•°
            if (isDealer) {
                // åº„å®¶å’Œç‰Œï¼Œè¿åº„ï¼šå±€æ•°ä¸å˜ï¼Œæœ¬åœº+1
                gameState.honba++;
            } else {
                // åº„å®¶æ²¡å’Œç‰Œï¼Œè½®åº„ï¼šåº„å®¶è½®æ¢ï¼Œå±€æ•°+1ï¼Œæœ¬åœºå½’0
                gameState.dealer = (gameState.dealer + 1) % 4;
                gameState.round++;
                gameState.honba = 0;
            }

            // æ¸…é™¤å¤é€‰æ¡†å’Œå½¹ç§é€‰æ‹©
            for (let i = 0; i < 4; i++) {
                document.getElementById(`riichi-${i}`).checked = false;
            }
            selectedYaku = [];
            updateSelectedYakuDisplay();
            document.getElementById('yaku-preview').style.display = 'none';
            document.getElementById('menzen').checked = true; // é‡ç½®ä¸ºé—¨æ¸…
            document.getElementById('menzen').disabled = false; // è§£é”é—¨æ¸…å¤é€‰æ¡†
            document.getElementById('dora-count').value = 0;
            document.getElementById('aka-dora-count').value = 0;
            document.getElementById('ura-dora-count').value = 0;
            updateLocks();

            saveState();
            updateDisplay();
            updateYakuPreview();

            if (gameState.gameEnded) {
                showMessage(t('msg_game_end'), 'success');
            } else {
                showMessage(t('msg_record_success'), 'success');
            }
        }

        // è®°å½•æµå±€
        function recordRyuukyoku() {
            // è·å–å¬ç‰Œç©å®¶
            const tenpaiPlayers = [];
            for (let i = 0; i < 4; i++) {
                if (document.getElementById(`tenpai-${i}`).checked) {
                    tenpaiPlayers.push(i);
                }
            }

            // è·å–ç«‹ç›´ç©å®¶
            const riichiPlayers = [];
            for (let i = 0; i < 4; i++) {
                if (document.getElementById(`ryuukyoku-riichi-${i}`).checked) {
                    riichiPlayers.push(i);
                }
            }

            const tenpaiCount = tenpaiPlayers.length;
            const newScores = [...gameState.scores];

            // è®¡ç®—å¬ç‰Œè´¹
            // 0äººå¬ç‰Œæˆ–4äººå¬ç‰Œï¼šä¸ç§»åŠ¨ç‚¹æ•°
            // 1äººå¬ç‰Œï¼šå…¶ä»–3äººå„ç»™1000ç‚¹
            // 2äººå¬ç‰Œï¼šæœªå¬ç‰Œçš„2äººå„ç»™1500ç‚¹
            // 3äººå¬ç‰Œï¼šæœªå¬ç‰Œçš„1äººç»™3000ç‚¹
            if (tenpaiCount === 1) {
                const tenpaiPlayer = tenpaiPlayers[0];
                for (let i = 0; i < 4; i++) {
                    if (i !== tenpaiPlayer) {
                        newScores[i] -= 1000;
                        newScores[tenpaiPlayer] += 1000;
                    }
                }
            } else if (tenpaiCount === 2) {
                for (let i = 0; i < 4; i++) {
                    if (tenpaiPlayers.includes(i)) {
                        newScores[i] += 1500;
                    } else {
                        newScores[i] -= 1500;
                    }
                }
            } else if (tenpaiCount === 3) {
                for (let i = 0; i < 4; i++) {
                    if (tenpaiPlayers.includes(i)) {
                        newScores[i] += 1000;
                    } else {
                        newScores[i] -= 3000;
                    }
                }
            }

            // æ‰£é™¤ç«‹ç›´ç©å®¶çš„1000ç‚¹
            riichiPlayers.forEach(playerId => {
                newScores[playerId] -= 1000;
            });

            // åˆ¤æ–­æ˜¯å¦è¿åº„
            const dealerTenpai = tenpaiPlayers.includes(gameState.dealer);

            // è®°å½•å†å²
            const record = {
                type: 'ryuukyoku',
                tenpaiPlayers: [...tenpaiPlayers],
                riichiPlayers: [...riichiPlayers],
                dealerTenpai,
                scoreBefore: [...gameState.scores],
                scoreAfter: [...newScores],
                roundBefore: gameState.round,
                dealerBefore: gameState.dealer,
                honbaBefore: gameState.honba,
                riichiSticksBefore: gameState.riichiSticks,
                riichiSticksAfter: gameState.riichiSticks + riichiPlayers.length,
                timestamp: Date.now()
            };

            gameState.history.push(record);
            gameState.scores = newScores;

            // æ¸…ç©ºæ’¤é”€æ ˆï¼ˆæ–°æ“ä½œä¼šä½¿ä¹‹å‰çš„æ’¤é”€æ— æ•ˆï¼‰
            gameState.undoStack = [];

            // æ›´æ–°ç«‹ç›´æ£’ï¼ˆæµå±€åç«‹ç›´æ£’ç•™åœ¨æ¡Œä¸Šï¼Œå¹¶å¢åŠ æœ¬å±€æ–°å¢çš„ç«‹ç›´æ£’ï¼‰
            gameState.riichiSticks += riichiPlayers.length;

            // æ£€æŸ¥å¯¹å±€æ˜¯å¦ç»“æŸ
            if (checkGameEnd(true, dealerTenpai)) {
                gameState.gameEnded = true;
            }

            // æµå±€æ—¶æœ¬åœºæ•°æ€»æ˜¯+1
            gameState.honba++;

            // æ›´æ–°åº„å®¶å’Œå±€æ•°
            if (dealerTenpai) {
                // åº„å®¶å¬ç‰Œï¼Œè¿åº„ï¼šå±€æ•°ä¸å˜
            } else {
                // åº„å®¶æœªå¬ç‰Œï¼Œè½®åº„ï¼šåº„å®¶è½®æ¢ï¼Œå±€æ•°+1
                gameState.dealer = (gameState.dealer + 1) % 4;
                gameState.round++;
            }

            // æ¸…é™¤å¤é€‰æ¡†
            for (let i = 0; i < 4; i++) {
                document.getElementById(`tenpai-${i}`).checked = false;
                document.getElementById(`ryuukyoku-riichi-${i}`).checked = false;
            }

            saveState();
            updateDisplay();

            if (gameState.gameEnded) {
                showMessage(t('msg_ryuukyoku_success_end'), 'success', 'ryuukyoku-message');
            } else {
                showMessage(t('msg_ryuukyoku_success'), 'success', 'ryuukyoku-message');
            }
        }

        // æ’¤é”€ä¸Šä¸€å±€
        function undoLast() {
            if (gameState.history.length === 0) {
                showMessage(t('msg_no_history'), 'error');
                return;
            }

            const lastRecord = gameState.history.pop();

            // å°†æ’¤é”€çš„è®°å½•æ”¾å…¥æ’¤é”€æ ˆ
            gameState.undoStack.push(lastRecord);

            gameState.scores = lastRecord.scoreBefore;
            gameState.round = lastRecord.roundBefore;
            gameState.dealer = lastRecord.dealerBefore;
            gameState.honba = lastRecord.honbaBefore;
            gameState.riichiSticks = lastRecord.riichiSticksBefore;
            gameState.gameEnded = false; // æ’¤é”€åå¯¹å±€ç»§ç»­

            saveState();
            updateDisplay();
            showMessage(t('msg_undo_success'), 'success');
        }

        // æ’¤é”€æ’¤é”€ï¼ˆé‡åšï¼‰
        function redoLast() {
            if (gameState.undoStack.length === 0) {
                showMessage(t('msg_no_undo_stack'), 'error');
                return;
            }

            const lastUndone = gameState.undoStack.pop();

            // å°†è®°å½•é‡æ–°åŠ å…¥å†å²
            gameState.history.push(lastUndone);
            gameState.scores = lastUndone.scoreAfter;
            gameState.round = lastUndone.roundBefore;
            gameState.dealer = lastUndone.dealerBefore;
            gameState.honba = lastUndone.honbaBefore;
            gameState.riichiSticks = lastUndone.riichiSticksBefore;

            // é‡æ–°åº”ç”¨çŠ¶æ€æ›´æ–°é€»è¾‘
            if (lastUndone.type === 'win') {
                gameState.riichiSticks = 0;
                if (lastUndone.isDealer) {
                    gameState.honba++;
                } else {
                    gameState.dealer = (gameState.dealer + 1) % 4;
                    gameState.round++;
                    gameState.honba = 0;
                }
            } else if (lastUndone.type === 'ryuukyoku') {
                gameState.riichiSticks = lastUndone.riichiSticksBefore + (lastUndone.riichiPlayers?.length || 0);
                gameState.honba++;
                if (!lastUndone.dealerTenpai) {
                    gameState.dealer = (gameState.dealer + 1) % 4;
                    gameState.round++;
                }
            }

            // æ£€æŸ¥æ˜¯å¦å¯¹å±€ç»“æŸ
            if (lastUndone.type === 'win') {
                if (checkGameEnd(lastUndone.isDealer, true)) {
                    gameState.gameEnded = true;
                }
            } else if (lastUndone.type === 'ryuukyoku') {
                if (checkGameEnd(true, lastUndone.dealerTenpai)) {
                    gameState.gameEnded = true;
                }
            }

            saveState();
            updateDisplay();
            showMessage(t('msg_redo_success'), 'success');
        }

        // æ¸…ç©ºå†å²
        function clearHistory() {
            if (!confirm(t('msg_clear_confirm'))) return;

            const initialScore = getInitialScore(gameState.rule);
            gameState.scores = [initialScore, initialScore, initialScore, initialScore];
            gameState.history = [];
            gameState.undoStack = [];
            gameState.round = 0;
            gameState.dealer = 0;
            gameState.honba = 0;
            gameState.riichiSticks = 0;
            gameState.gameEnded = false;

            saveState();
            updateDisplay();
            showMessage(t('msg_history_cleared'), 'success');
        }

        // è·å–å±€æ•°æ˜¾ç¤ºæ–‡æœ¬
        function getRoundText(round, honba) {
            const roundNames = t('round_names');
            const roundIndex = Math.floor(round / 4);
            const subRound = (round % 4) + 1;
            let roundName;
            if (LANGUAGE === 'en') {
                roundName = `${roundNames[roundIndex % 4]} ${subRound}`;
            } else {
                roundName = `${roundNames[roundIndex % 4]}${subRound}${t('round_suffix')}`;
            }
            if (honba > 0) {
                if (LANGUAGE === 'en') {
                    return `${roundName} Â· ${honba}${t('honba_suffix')}`;
                }
                return `${roundName}${honba}${t('honba_suffix')}`;
            }
            return roundName;
        }

        function formatScoreDelta(before, after) {
            const delta = after - before;
            const formattedDelta = delta > 0 ? `+${delta.toLocaleString()}` : delta.toLocaleString();
            return `${before.toLocaleString()} â†’ ${after.toLocaleString()} (${formattedDelta})`;
        }

        function renderScoreChanges(record, players) {
            if (!record.scoreBefore || !record.scoreAfter) return '';
            const rows = record.scoreBefore.map((score, i) => {
                const after = record.scoreAfter[i];
                const delta = after - score;
                const color = delta > 0 ? '#28a745' : (delta < 0 ? '#dc3545' : '#666');
                const playerName = players[i] || getDefaultPlayerName(i);
                return `<div style="display: flex; justify-content: space-between; gap: 12px;">
                    <span>${playerName}</span>
                    <span style="color: ${color}; font-weight: 600;">${formatScoreDelta(score, after)}</span>
                </div>`;
            }).join('');
            const riichiBefore = record.riichiSticksBefore !== undefined ? record.riichiSticksBefore : 0;
            let riichiAfter;
            if (record.riichiSticksAfter !== undefined) {
                riichiAfter = record.riichiSticksAfter;
            } else if (record.type === 'win') {
                riichiAfter = 0;
            } else if (record.type === 'ryuukyoku') {
                const added = record.riichiPlayers ? record.riichiPlayers.length : 0;
                riichiAfter = riichiBefore + added;
            } else if (record.riichiSticks !== undefined) {
                riichiAfter = record.riichiSticks;
            } else {
                riichiAfter = riichiBefore;
            }
            const riichiDelta = riichiAfter - riichiBefore;
            const riichiColor = riichiDelta > 0 ? '#28a745' : (riichiDelta < 0 ? '#dc3545' : '#666');
            const unit = t('label_riichi_sticks_suffix');
            const formatValue = (value) => {
                const numeric = Number(value);
                const formatted = Number.isNaN(numeric) ? value : numeric.toLocaleString();
                return unit ? `${formatted}${unit}` : `${formatted}`;
            };
            const deltaPrefix = riichiDelta > 0 ? '+' : (riichiDelta < 0 ? '-' : '');
            const riichiText = `${formatValue(riichiBefore)} â†’ ${formatValue(riichiAfter)} (${deltaPrefix}${formatValue(Math.abs(riichiDelta))})`;
            return `<div style="padding: 8px 12px; background: rgba(102, 126, 234, 0.08); border-radius: 6px; min-width: 200px; margin-left: 6px;">
                <div style="font-weight: 600; margin-bottom: 6px; color: #667eea;">${t('history_score_changes')}</div>
                ${rows}
                <div style="display: flex; justify-content: space-between; gap: 12px; margin-top: 6px;">
                    <span>${t('history_riichi_changes')}</span>
                    <span style="color: ${riichiColor}; font-weight: 600;">${riichiText}</span>
                </div>
            </div>`;
        }

        // æ›´æ–°å†å²æ˜¾ç¤º
        function updateHistory() {
            const historyDiv = document.getElementById('history');
            historyDiv.innerHTML = '';

            if (gameState.history.length === 0) {
                historyDiv.innerHTML = `<p style="text-align: center; color: #999;">${t('history_empty')}</p>`;
                return;
            }

            gameState.history.slice().reverse().forEach((record, index) => {
                const actualIndex = gameState.history.length - 1 - index;

                // è·å–å±€æ•°å’Œæœ¬åœºæ•°
                const roundText = getRoundText(record.roundBefore, record.honbaBefore);
                const playersSnapshot = record.scoreBefore
                    ? record.scoreBefore.map((_, idx) => gameState.players[idx] || getDefaultPlayerName(idx))
                    : [];

                let detailsHtml = '';

                if (record.type === 'ryuukyoku') {
                    // æµå±€è®°å½•
                    const nameSeparator = LANGUAGE === 'en' ? ', ' : 'ã€';
                    const tenpaiNames = (record.tenpaiPlayers || []).map(id =>
                        gameState.players[id] || getDefaultPlayerName(id)
                    ).join(nameSeparator);
                    let tenpaiText;
                    if (record.tenpaiPlayers.length === 0) {
                        tenpaiText = t('history_all_noten');
                    } else if (record.tenpaiPlayers.length === 4) {
                        tenpaiText = t('history_all_tenpai');
                    } else {
                        tenpaiText = `${t('history_tenpai_prefix')}${tenpaiNames}`;
                    }

                    let riichiText = '';
                    if (record.riichiPlayers && record.riichiPlayers.length > 0) {
                        const riichiNames = record.riichiPlayers.map(id => gameState.players[id] || getDefaultPlayerName(id)).join(nameSeparator);
                        riichiText = `<br>${t('riichi_players_label')}: ${riichiNames}`;
                    }

                    const dealerStatus = record.dealerTenpai ? t('history_continue') : t('history_change');
                    const scoreChanges = renderScoreChanges(record, playersSnapshot);

                    detailsHtml = `
                        <div style="display:flex; gap:12px; align-items:flex-start; flex-wrap: wrap;">
                            <div style="min-width:200px; color: #667eea; font-weight: bold;">
                                <div>${roundText}</div>
                                <div style="font-weight: 600; color: #333; margin-top: 4px;">
                                    <strong>${t('history_ryuukyoku')}</strong> (${dealerStatus})
                                </div>
                                <div style="margin-top: 4px; color: #444; font-weight: 500;">${tenpaiText}${riichiText}</div>
                            </div>
                            ${scoreChanges}
                        </div>
                    `;
                } else {
                    // å’Œç‰Œè®°å½•
                    const nameSeparator = LANGUAGE === 'en' ? ', ' : 'ã€';
                    const winnerName = gameState.players[record.winnerId] || getDefaultPlayerName(record.winnerId);
                    const loserName = record.isTsumo
                        ? t('tsumo_text')
                        : (gameState.players[record.loserId] || getDefaultPlayerName(record.loserId));
                    let pointsStr;
                    if (record.isTsumo) {
                        pointsStr = record.points.join('/');
                    } else {
                        pointsStr = `${t('ron_text')} ${record.points}${LANGUAGE === 'en' ? ' pts' : 'ç‚¹'}`;
                    }

                    // æ˜¾ç¤ºå½¹ç§ã€é—¨æ¸…çŠ¶æ€ä»¥åŠå®ç‰Œä¿¡æ¯
                    const yakuSegments = [];
                    if (record.yaku) {
                        const menzenStatus = record.isMenzen === false ? (LANGUAGE === 'en' ? 'Open ' : 'å‰¯éœ² ') : '';
                        yakuSegments.push(`${menzenStatus}${record.yaku}`);
                    }
                    const doraSegments = [];
                    if (record.doraCount) doraSegments.push(LANGUAGE === 'en'
                        ? `Dora ${record.doraCount}${t('han_unit')}`
                        : `å®ç‰Œ${record.doraCount}ç•ª`);
                    if (record.akaDoraCount) doraSegments.push(LANGUAGE === 'en'
                        ? `Red ${record.akaDoraCount}${t('han_unit')}`
                        : `èµ¤${record.akaDoraCount}ç•ª`);
                    if (record.uraDoraCount) doraSegments.push(LANGUAGE === 'en'
                        ? `Ura ${record.uraDoraCount}${t('han_unit')}`
                        : `é‡Œ${record.uraDoraCount}ç•ª`);
                    if (doraSegments.length > 0) {
                        yakuSegments.push(doraSegments.join(' + '));
                    }
                    const yakuText = yakuSegments.length > 0
                        ? `<br><small style="color: #28a745;">${t('yaku_label')}: ${yakuSegments.join(' Â· ')}</small>`
                        : '';

                    const extraInfo = [];
                    if (record.honbaPoints > 0) extraInfo.push(t('extra_honba', { points: record.honbaPoints }));
                    if (record.riichiPoints > 0) extraInfo.push(t('extra_riichi', { points: record.riichiPoints }));
                    if (record.riichiPlayers && record.riichiPlayers.length > 0) {
                        const riichiNames = record.riichiPlayers.map(id => gameState.players[id] || getDefaultPlayerName(id)).join(nameSeparator);
                        extraInfo.push(`${t('riichi_players_label')}: ${riichiNames}`);
                    }
                    const extraText = extraInfo.length > 0 ? `<br><small>${extraInfo.join(t('history_extra_separator'))}</small>` : '';

                    const dealerSuffix = record.isDealer ? t('history_dealer_suffix') : '';
                    const summaryText = t('history_winner_summary', {
                        winner: winnerName,
                        han: record.han,
                        fu: record.fu,
                        dealer: dealerSuffix
                    });
                    const loserSummary = record.isTsumo
                        ? t('history_tsumo_summary', { points: pointsStr })
                        : t('history_loser_summary', { loser: loserName, points: pointsStr });

                    const scoreChanges = renderScoreChanges(record, playersSnapshot);

                    detailsHtml = `
                        <div style="display:flex; gap:12px; align-items:flex-start; flex-wrap: wrap;">
                            <div style="min-width:200px; color: #667eea; font-weight: bold;">
                                <div>${roundText}</div>
                                <div style="color: #333; font-weight: 600; margin-top: 4px;">${summaryText}</div>
                                ${yakuText}
                                <div style="margin-top: 4px; color: #444; font-weight: 500;">${loserSummary}${extraText}</div>
                            </div>
                            ${scoreChanges}
                        </div>
                    `;
                }

                // åªæœ‰æœ€æ–°çš„ä¸€æ¡è®°å½•(index === 0)æ‰æ˜¾ç¤ºæ’¤é”€æŒ‰é’®
                const undoButton = index === 0
                    ? `<button type="button" class="undo-last-btn">${t('undo_button')}</button>`
                    : '';

                historyDiv.innerHTML += `
                    <div class="history-item">
                        <div class="details">
                            ${detailsHtml}
                        </div>
                        ${undoButton}
                    </div>
                `;
            });
        }

        function setCopyStatus(message, isError = false) {
            const statusEl = document.getElementById('copy-status');
            if (!statusEl) return;
            statusEl.textContent = message;
            statusEl.style.color = isError ? '#dc3545' : '#28a745';
            if (copyStatusTimeout) {
                clearTimeout(copyStatusTimeout);
            }
            copyStatusTimeout = setTimeout(() => {
                statusEl.textContent = '';
            }, 3000);
        }

        async function copyTextToClipboard(text) {
            if (!text) {
                setCopyStatus(t('copy_none'), true);
                return false;
            }
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textarea);
                    if (!successful) {
                        throw new Error(t('copy_exec_failed'));
                    }
                }
                return true;
            } catch (err) {
                console.error('Clipboard copy failed', err);
                setCopyStatus(t('copy_failed') + err.message, true);
                return false;
            }
        }

        async function copyGameSummary(auto = false) {
            const summaryElement = document.getElementById('game-summary-json');
            if (!summaryElement) return;
            const text = summaryElement.textContent.trim();
            if (!text) {
                if (!auto) setCopyStatus(t('copy_none'), true);
                return;
            }
            if (auto && text === lastCopiedSummary) {
                return;
            }
            const ok = await copyTextToClipboard(text);
            if (ok) {
                lastCopiedSummary = text;
                setCopyStatus(auto ? t('copy_auto') : t('copy_success'));
            }
        }

        function importGameData() {
            const jsonInput = prompt('è¯·ç²˜è´´JSONæ•°æ®ï¼š\n(Paste JSON data:)');
            if (!jsonInput || !jsonInput.trim()) {
                return;
            }

            try {
                // éªŒè¯hash
                const hashVerification = verifyJsonHash(jsonInput);
                if (hashVerification.error) {
                    if (!confirm(`è­¦å‘Šï¼šæ— æ³•éªŒè¯æ•°æ®å®Œæ•´æ€§ (${hashVerification.error})ã€‚\næ˜¯å¦ç»§ç»­å¯¼å…¥ï¼Ÿ\n\nWarning: Cannot verify data integrity (${hashVerification.error}).\nContinue importing?`)) {
                        return;
                    }
                } else if (!hashVerification.valid) {
                    if (!confirm(`è­¦å‘Šï¼šHashå€¼ä¸åŒ¹é…ï¼æ•°æ®å¯èƒ½å·²è¢«ä¿®æ”¹ã€‚\næä¾›çš„Hash: ${hashVerification.providedHash}\nè®¡ç®—çš„Hash: ${hashVerification.calculatedHash}\næ˜¯å¦ç»§ç»­å¯¼å…¥ï¼Ÿ\n\nWarning: Hash mismatch! Data may have been modified.\nProvided Hash: ${hashVerification.providedHash}\nCalculated Hash: ${hashVerification.calculatedHash}\nContinue importing?`)) {
                        return;
                    }
                }

                // æå–JSONéƒ¨åˆ†ï¼ˆå»æ‰hashæ³¨é‡Šï¼‰
                const jsonPart = jsonInput.split('// Hash:')[0].trim();
                const data = JSON.parse(jsonPart);

                // éªŒè¯æ•°æ®ç»“æ„
                if (!data.players || !Array.isArray(data.players) || data.players.length !== 4) {
                    throw new Error('æ— æ•ˆçš„ç©å®¶æ•°æ® (Invalid player data)');
                }
                if (!data.rounds || !Array.isArray(data.rounds)) {
                    throw new Error('æ— æ•ˆçš„å¯¹å±€è®°å½• (Invalid rounds data)');
                }

                // ç¡®è®¤å¯¼å…¥
                if (!confirm(`ç¡®è®¤å¯¼å…¥æ•°æ®ï¼Ÿ\nè¿™å°†è¦†ç›–å½“å‰çš„å¯¹å±€è®°å½•ï¼\n\nç©å®¶: ${data.players.join(', ')}\nè§„åˆ™: ${data.rule}\nå¯¹å±€æ•°: ${data.rounds.length}\n\nConfirm import?\nThis will overwrite current game records!\n\nPlayers: ${data.players.join(', ')}\nRule: ${data.rule}\nRounds: ${data.rounds.length}`)) {
                    return;
                }

                // è¿˜åŸæ¸¸æˆçŠ¶æ€
                restoreGameState(data);

                setCopyStatus('æ•°æ®å¯¼å…¥æˆåŠŸï¼(Data imported successfully!)', false);
                showMessage('æ•°æ®å¯¼å…¥æˆåŠŸï¼', 'success');

            } catch (error) {
                console.error('Import failed', error);
                alert(`å¯¼å…¥å¤±è´¥ï¼š${error.message}\n\nImport failed: ${error.message}`);
            }
        }

        function restoreGameState(data) {
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            const initialScore = data.rule === 'wrc' ? 30000 : 25000;
            gameState.players = [...data.players];
            gameState.rule = data.rule;
            gameState.scores = [initialScore, initialScore, initialScore, initialScore];
            gameState.round = 0;
            gameState.dealer = 0;
            gameState.honba = 0;
            gameState.riichiSticks = 0;
            gameState.history = [];
            gameState.gameEnded = false;

            // é‡æ”¾æ‰€æœ‰å¯¹å±€
            data.rounds.forEach((round, index) => {
                if (round.type === 'win') {
                    restoreWinRecord(round, index);
                } else if (round.type === 'ryuukyoku') {
                    restoreRyuukyokuRecord(round, index);
                }
            });

            // ä¿å­˜çŠ¶æ€å¹¶æ›´æ–°æ˜¾ç¤º
            saveState();
            updateDisplay();
        }

        function restoreWinRecord(round, index) {
            const winnerId = gameState.players.indexOf(round.result.winner);
            const loserId = round.result.isTsumo ? -1 : gameState.players.indexOf(round.result.loser);
            const riichiPlayers = (round.riichiPlayers || []).map(name => gameState.players.indexOf(name)).filter(id => id >= 0);

            const record = {
                type: 'win',
                winnerId: winnerId,
                loserId: loserId,
                isTsumo: round.result.isTsumo,
                han: round.result.han,
                fu: round.result.fu,
                yaku: round.result.yaku.join(' '),
                yakuHan: round.result.yakuHan || round.result.han,
                doraCount: round.result.dora?.dora || 0,
                akaDoraCount: round.result.dora?.aka || 0,
                uraDoraCount: round.result.dora?.ura || 0,
                isMenzen: round.result.isMenzen,
                isDealer: round.result.isDealer,
                points: round.result.points,
                riichiPlayers: riichiPlayers,
                honbaPoints: round.result.honbaPoints || 0,
                riichiPoints: round.result.riichiPoints || 0,
                scoreBefore: round.scores.map(s => s.before),
                scoreAfter: round.scores.map(s => s.after),
                roundBefore: round.round.number,
                dealerBefore: gameState.players.indexOf(round.round.dealer),
                honbaBefore: round.round.honba,
                riichiSticksBefore: round.round.riichiSticks,
                timestamp: Date.now()
            };

            gameState.history.push(record);
            gameState.scores = [...record.scoreAfter];
            gameState.round = record.roundBefore;
            gameState.dealer = record.dealerBefore;
            gameState.honba = record.honbaBefore;
            gameState.riichiSticks = 0;

            // æ›´æ–°ä¸‹ä¸€å±€çš„çŠ¶æ€
            if (record.isDealer) {
                gameState.honba++;
            } else {
                gameState.dealer = (gameState.dealer + 1) % 4;
                gameState.round++;
                gameState.honba = 0;
            }
        }

        function restoreRyuukyokuRecord(round, index) {
            const tenpaiPlayers = (round.result?.tenpaiPlayers || []).map(name => gameState.players.indexOf(name)).filter(id => id >= 0);
            const riichiPlayers = (round.riichiPlayers || []).map(name => gameState.players.indexOf(name)).filter(id => id >= 0);
            const dealerTenpai = tenpaiPlayers.includes(gameState.dealer);

            const record = {
                type: 'ryuukyoku',
                tenpaiPlayers: tenpaiPlayers,
                riichiPlayers: riichiPlayers,
                dealerTenpai: dealerTenpai,
                scoreBefore: round.scores.map(s => s.before),
                scoreAfter: round.scores.map(s => s.after),
                roundBefore: round.round.number,
                dealerBefore: gameState.players.indexOf(round.round.dealer),
                honbaBefore: round.round.honba,
                riichiSticksBefore: round.round.riichiSticks,
                timestamp: Date.now()
            };

            gameState.history.push(record);
            gameState.scores = [...record.scoreAfter];
            gameState.round = record.roundBefore;
            gameState.dealer = record.dealerBefore;
            gameState.honba = record.honbaBefore;
            gameState.riichiSticks = record.riichiSticksBefore + riichiPlayers.length;

            // æ›´æ–°ä¸‹ä¸€å±€çš„çŠ¶æ€
            gameState.honba++;
            if (!dealerTenpai) {
                gameState.dealer = (gameState.dealer + 1) % 4;
                gameState.round++;
            }
        }

        function generateGameSummary() {
            const players = gameState.players.map((name, i) => name || getDefaultPlayerName(i));
            const initialScore = getInitialScore(gameState.rule);
            const rounds = gameState.history.map((record, index) => {
                const roundNumber = record.roundBefore !== undefined ? record.roundBefore : gameState.round;
                const honbaBefore = record.honbaBefore !== undefined ? record.honbaBefore : 0;
                const riichiSticksBefore = record.riichiSticksBefore !== undefined ? record.riichiSticksBefore : 0;
                const dealerIndex = record.dealerBefore !== undefined ? record.dealerBefore : gameState.dealer;
                const roundName = getRoundText(roundNumber, honbaBefore);
                const riichiPlayers = (record.riichiPlayers || []).map(id => players[id]);
                const scoreBeforeArr = record.scoreBefore || gameState.scores;
                const scoreAfterArr = record.scoreAfter || scoreBeforeArr;
                const base = {
                    index: index + 1,
                    type: record.type,
                    round: {
                        number: roundNumber,
                        name: roundName,
                        honba: honbaBefore,
                        riichiSticks: riichiSticksBefore,
                        dealer: players[dealerIndex]
                    },
                    scores: scoreBeforeArr.map((before, i) => {
                        const after = scoreAfterArr[i] !== undefined ? scoreAfterArr[i] : before;
                        return {
                            player: players[i],
                            before,
                            after,
                            delta: after - before
                        };
                    })
                };

                if (record.type === 'win') {
                    const yakuList = record.yaku ? record.yaku.split(/\s+/).filter(Boolean) : [];
                    const loserNameText = record.isTsumo
                        ? 'è‡ªæ‘¸'
                        : (players[record.loserId] || getDefaultPlayerName(record.loserId || 0));
                    base.result = {
                        winner: players[record.winnerId],
                        loser: loserNameText,
                        isTsumo: record.isTsumo,
                        isDealer: record.isDealer,
                        isMenzen: record.isMenzen !== false,
                        han: record.han,
                        fu: record.fu,
                        yaku: yakuList,
                        yakuHan: record.yakuHan,
                        dora: {
                            dora: record.doraCount,
                            aka: record.akaDoraCount,
                            ura: record.uraDoraCount
                        },
                        points: record.isTsumo
                            ? { type: 'tsumo', payments: record.points }
                            : { type: 'ron', payment: record.points },
                        honbaBonus: record.honbaPoints,
                        riichiBonus: record.riichiPoints,
                        riichiPlayers
                    };
                    base.result.note = record.isTsumo ? t('summary_note_tsumo') : t('summary_note_ron');
                } else {
                    const tenpaiPlayers = (record.tenpaiPlayers || []).map(id => players[id]);
                    base.result = {
                        tenpaiPlayers,
                        riichiPlayers,
                        dealerTenpai: record.dealerTenpai
                    };
                }

                const riichiAfter = record.type === 'win'
                    ? 0
                    : riichiSticksBefore + (record.riichiPlayers ? record.riichiPlayers.length : 0);
                base.round.riichiSticksAfter = riichiAfter;
                base.round.honbaAfter = record.type === 'win'
                    ? ((record.isDealer ? honbaBefore + 1 : 0))
                    : honbaBefore + 1;

                return base;
            });

            const summary = {
                rule: gameState.rule,
                players,
                initialScore,
                gameEnded: gameState.gameEnded,
                currentRound: getRoundText(gameState.round, gameState.honba),
                dealer: players[gameState.dealer],
                honba: gameState.honba,
                riichiSticks: gameState.riichiSticks,
                scores: gameState.scores.map((score, i) => ({
                    player: players[i],
                    score
                })),
                rounds
            };

            if (gameState.gameEnded && gameState.history.length > 0) {
                summary.finalResults = calculateFinalResults().map(result => ({
                    playerIndex: result.index,
                    rank: result.rank,
                    player: result.name,
                    finalScore: result.finalScore,
                    rawScore: result.rawScore,
                    uma: result.uma,
                    riichiBonus: result.riichiBonus,
                    totalScore: result.totalScore
                }));
            }

            return summary;
        }

        // è®¡ç®—å­—ç¬¦ä¸²çš„ç®€å•hashå€¼ï¼ˆä½¿ç”¨DJB2ç®—æ³•ï¼‰
        function calculateHash(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i); // hash * 33 + c
            }
            // è½¬æ¢ä¸ºæ­£æ•°çš„16è¿›åˆ¶å­—ç¬¦ä¸²
            return (hash >>> 0).toString(16).padStart(8, '0');
        }

        // éªŒè¯JSONå­—ç¬¦ä¸²çš„hashå€¼
        // ä½¿ç”¨æ–¹æ³•ï¼šå°†åŒ…å«hashçš„å®Œæ•´å­—ç¬¦ä¸²ç²˜è´´è¿›æ¥éªŒè¯
        // ä¾‹å¦‚: verifyJsonHash(jsonStringWithHash)
        function verifyJsonHash(jsonWithHash) {
            try {
                // æå–hashå€¼
                const hashMatch = jsonWithHash.match(/\/\/ Hash: ([a-f0-9]{8})/);
                if (!hashMatch) {
                    return { valid: false, error: 'æœªæ‰¾åˆ°Hashå€¼' };
                }
                const providedHash = hashMatch[1];

                // æå–JSONéƒ¨åˆ†ï¼ˆå»æ‰hashæ³¨é‡Šï¼‰
                const jsonPart = jsonWithHash.split('// Hash:')[0].trim();

                // è®¡ç®—å®é™…hash
                const compactJson = jsonPart.replace(/\s+/g, '');
                const calculatedHash = calculateHash(compactJson);

                return {
                    valid: providedHash === calculatedHash,
                    providedHash,
                    calculatedHash,
                    match: providedHash === calculatedHash
                };
            } catch (error) {
                return { valid: false, error: error.message };
            }
        }

        function updateGameSummary() {
            const summaryElement = document.getElementById('game-summary-json');
            if (!summaryElement) return;
            try {
                const summary = generateGameSummary();
                const jsonString = JSON.stringify(summary, null, 2);

                // è®¡ç®—å»æ‰æ‰€æœ‰ç©ºæ ¼å’Œæ¢è¡Œåçš„JSONå­—ç¬¦ä¸²çš„hash
                const compactJson = jsonString.replace(/\s+/g, '');
                const hash = calculateHash(compactJson);

                // åœ¨JSONå­—ç¬¦ä¸²åæ·»åŠ hashå€¼ä½œä¸ºæ³¨é‡Š
                summaryElement.textContent = jsonString + '\n\n// Hash: ' + hash;

                if (gameState.history.length > 0) {
                    copyGameSummary(true);
                }
            } catch (error) {
                console.error('Failed to generate game summary', error);
                summaryElement.textContent = `// æ— æ³•ç”Ÿæˆå¯¹å±€æ‘˜è¦: ${error.message}`;
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(msg, type, targetId = 'message') {
            const messageDiv = document.getElementById(targetId);
            messageDiv.className = type;
            messageDiv.textContent = msg;
            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.className = '';
            }, 3000);
        }

        // ä¿å­˜çŠ¶æ€
        function saveState() {
            localStorage.setItem('mahjongGameState', JSON.stringify(gameState));
        }

        // åŠ è½½çŠ¶æ€
        function loadState() {
            const saved = localStorage.getItem('mahjongGameState');
            if (saved) {
                gameState = JSON.parse(saved);

                // å‘åå…¼å®¹ï¼šä¸ºæ—§è®°å½•æ·»åŠ typeå­—æ®µ
                if (gameState.history) {
                    gameState.history.forEach(record => {
                        if (!record.type) {
                            record.type = 'win';
                        }
                        if (record.doraCount === undefined) record.doraCount = 0;
                        if (record.akaDoraCount === undefined) record.akaDoraCount = 0;
                        if (record.uraDoraCount === undefined) record.uraDoraCount = 0;
                        if (record.yakuHan === undefined && record.han !== undefined) {
                            record.yakuHan = Math.max(
                                record.han - record.doraCount - record.akaDoraCount - record.uraDoraCount,
                                0
                            );
                        }
                    });
                }

                // ç¡®ä¿honbaå’ŒriichiStickså­˜åœ¨
                if (gameState.honba === undefined) gameState.honba = 0;
                if (gameState.riichiSticks === undefined) gameState.riichiSticks = 0;
                if (gameState.gameEnded === undefined) gameState.gameEnded = false;
                if (gameState.undoStack === undefined) gameState.undoStack = [];

                // æ¢å¤è§„åˆ™é€‰æ‹©
                document.querySelectorAll('.rule-btn-compact').forEach(btn => {
                    if (btn.dataset.rule === gameState.rule) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
